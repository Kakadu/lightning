diff -urN ocaml-4.00-ios/Makefile ocaml-4.00/Makefile
--- ocaml-4.00-ios/Makefile	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/Makefile	2012-07-24 09:48:16.000000000 +0400
@@ -17,17 +17,17 @@
 include config/Makefile
 include stdlib/StdlibModules
 
-CAMLC=ocamlc.opt -I boot
-CAMLOPT=ocamlopt.opt
+CAMLC=boot/ocamlrun boot/ocamlc -nostdlib -I boot
+CAMLOPT=boot/ocamlrun ./ocamlopt -nostdlib -I stdlib -I otherlibs/dynlink
 COMPFLAGS= -strict-sequence -warn-error A $(INCLUDES)
 LINKFLAGS=
 
-CAMLYACC=ocamlyacc
+CAMLYACC=boot/ocamlyacc
 YACCFLAGS=-v
-CAMLLEX=ocamllex.opt
-CAMLDEP=ocamldep.opt
+CAMLLEX=boot/ocamlrun boot/ocamllex
+CAMLDEP=boot/ocamlrun tools/ocamldep
 DEPFLAGS=$(INCLUDES)
-CAMLRUN=ocamlrun
+CAMLRUN=byterun/ocamlrun
 SHELL=/bin/sh
 MKDIR=mkdir -p
 
@@ -105,14 +105,19 @@
 PERVASIVES=$(STDLIB_MODULES) outcometree topdirs toploop
 
 # For users who don't read the INSTALL file
-defaultentry: runtime runtimeopt ocamlopt.opt libraryopt otherlibrariesopt 
+defaultentry:
+	@echo "Please refer to the installation instructions in file INSTALL."
+	@echo "If you've just unpacked the distribution, something like"
+	@echo "	./configure"
+	@echo "	make world"
+	@echo "	make opt"
+	@echo "	make install"
+	@echo "should work.  But see the file INSTALL for more details."
 
 # Recompile the system using the bootstrap compiler
 all: runtime ocamlc ocamllex ocamlyacc ocamltools library ocaml \
   otherlibraries ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc
 
-optonly: 
-
 # Compile everything the first time
 world:
 	$(MAKE) coldstart
@@ -263,33 +268,6 @@
 	if test -d $(LIBDIR); then : ; else $(MKDIR) $(LIBDIR); fi
 	if test -d $(STUBLIBDIR); then : ; else $(MKDIR) $(STUBLIBDIR); fi
 	if test -d $(COMPLIBDIR); then : ; else $(MKDIR) $(COMPLIBDIR); fi
-	cp VERSION $(LIBDIR)/
-	cd byterun; $(MAKE) installopt
-	cd asmrun; $(MAKE) install
-	cp ocamlopt.opt $(BINDIR)/ocamlopt.opt$(EXE)
-	ln -fs $(BINDIR)/ocamlopt.opt $(BINDIR)/ocamlopt
-	cd stdlib; $(MAKE) installopt
-	for i in $(OTHERLIBRARIES); do \
-	  (cd otherlibs/$$i; $(MAKE) installopt) || exit $$?; \
-	done
-	cp asmcomp/*.cmi $(COMPLIBDIR)
-	cp compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlcommon.a \
-           compilerlibs/ocamloptcomp.cmxa compilerlibs/ocamloptcomp.a \
-           $(OPTSTART:.cmo=.cmx) $(OPTSTART:.cmo=.o) \
-           $(COMPLIBDIR)
-	cd $(COMPLIBDIR) && $(RANLIB) ocamlcommon.a ocamloptcomp.a
-	cd ocamldoc; $(MAKE) installopt
-	for i in $(OTHERLIBRARIES); \
-	  do (cd otherlibs/$$i; $(MAKE) installopt) || exit $$?; done
-	cp tools/ocamlmklib $(BINDIR)
-	cp config/Makefile $(LIBDIR)/Makefile.config
-
-
-installall:
-	if test -d $(BINDIR); then : ; else $(MKDIR) $(BINDIR); fi
-	if test -d $(LIBDIR); then : ; else $(MKDIR) $(LIBDIR); fi
-	if test -d $(STUBLIBDIR); then : ; else $(MKDIR) $(STUBLIBDIR); fi
-	if test -d $(COMPLIBDIR); then : ; else $(MKDIR) $(COMPLIBDIR); fi
 	if test -d $(MANDIR)/man$(MANEXT); then : ; \
 	  else $(MKDIR) $(MANDIR)/man$(MANEXT); fi
 	cp VERSION $(LIBDIR)/
@@ -344,7 +322,6 @@
            $(COMPLIBDIR)
 	cd $(COMPLIBDIR) && $(RANLIB) ocamlcommon.a ocamlbytecomp.a ocamloptcomp.a
 
-
 clean:: partialclean
 
 # Shared parts of the system
@@ -505,9 +482,6 @@
 	$(CAMLOPT) $(LINKFLAGS) -o ocamlopt.opt \
            compilerlibs/ocamlcommon.cmxa compilerlibs/ocamloptcomp.cmxa \
            $(OPTSTART:.cmo=.cmx)
-	@sed -e 's|@compiler@|ocamlc.opt|' \
-		driver/ocamlcomp.sh.in > ocamlcomp.sh
-	@chmod +x ocamlcomp.sh
 	@sed -e 's|@compiler@|$$topdir/ocamlopt.opt|' \
 	  driver/ocamlcomp.sh.in > ocamlcompopt.sh
 	@chmod +x ocamlcompopt.sh
@@ -602,7 +576,7 @@
 
 tools/cvt_emit: tools/cvt_emit.mll
 	cd tools; \
-	$(MAKE) CAMLC="ocamlc" cvt_emit
+	$(MAKE) CAMLC="../$(CAMLRUN) ../boot/ocamlc -I ../stdlib" cvt_emit
 
 # The "expunge" utility
 
@@ -685,9 +659,6 @@
 ocamltools: ocamlc ocamlyacc ocamllex asmcomp/cmx_format.cmi
 	cd tools; $(MAKE) all
 
-ocamlmklib:
-	cd tools; $(MAKE) ocamlmklib
-
 ocamltoolsopt: ocamlopt
 	cd tools; $(MAKE) opt
 
@@ -721,7 +692,7 @@
 	  (cd otherlibs/$$i; $(MAKE) RUNTIME=$(RUNTIME) all) || exit $$?; \
 	done
 
-otherlibrariesopt: ocamlmklib
+otherlibrariesopt:
 	for i in $(OTHERLIBRARIES); do \
 	  (cd otherlibs/$$i; $(MAKE) allopt) || exit $$?; \
 	done
@@ -837,6 +808,4 @@
 .PHONY: otherlibrariesopt package-macosx promote promote-cross
 .PHONY: restore runtime runtimeopt makeruntimeopt world world.opt
 
-
-
 include .depend
diff -urN ocaml-4.00-ios/Makefile.orig ocaml-4.00/Makefile.orig
--- ocaml-4.00-ios/Makefile.orig	2012-07-24 09:48:16.000000000 +0400
+++ ocaml-4.00/Makefile.orig	1970-01-01 03:00:00.000000000 +0300
@@ -1,811 +0,0 @@
-#########################################################################
-#                                                                       #
-#                                 OCaml                                 #
-#                                                                       #
-#            Xavier Leroy, projet Cristal, INRIA Rocquencourt           #
-#                                                                       #
-#   Copyright 1999 Institut National de Recherche en Informatique et    #
-#   en Automatique.  All rights reserved.  This file is distributed     #
-#   under the terms of the Q Public License version 1.0.                #
-#                                                                       #
-#########################################################################
-
-# $Id: Makefile 12750 2012-07-20 08:06:01Z doligez $
-
-# The main Makefile
-
-include config/Makefile
-include stdlib/StdlibModules
-
-CAMLC=boot/ocamlrun boot/ocamlc -nostdlib -I boot
-CAMLOPT=boot/ocamlrun ./ocamlopt -nostdlib -I stdlib -I otherlibs/dynlink
-COMPFLAGS= -strict-sequence -warn-error A $(INCLUDES)
-LINKFLAGS=
-
-CAMLYACC=boot/ocamlyacc
-YACCFLAGS=-v
-CAMLLEX=boot/ocamlrun boot/ocamllex
-CAMLDEP=boot/ocamlrun tools/ocamldep
-DEPFLAGS=$(INCLUDES)
-CAMLRUN=byterun/ocamlrun
-SHELL=/bin/sh
-MKDIR=mkdir -p
-
-CAMLP4OUT=$(CAMLP4:=out)
-CAMLP4OPT=$(CAMLP4:=opt)
-
-INCLUDES=-I utils -I parsing -I typing -I bytecomp -I asmcomp -I driver \
-	 -I toplevel
-
-UTILS=utils/misc.cmo utils/tbl.cmo utils/config.cmo \
-  utils/clflags.cmo utils/terminfo.cmo utils/ccomp.cmo utils/warnings.cmo \
-  utils/consistbl.cmo
-
-PARSING=parsing/location.cmo parsing/longident.cmo \
-  parsing/syntaxerr.cmo parsing/parser.cmo \
-  parsing/lexer.cmo parsing/parse.cmo parsing/printast.cmo
-
-TYPING=typing/ident.cmo typing/path.cmo \
-  typing/primitive.cmo typing/types.cmo \
-  typing/btype.cmo typing/oprint.cmo \
-  typing/subst.cmo typing/predef.cmo \
-  typing/datarepr.cmo typing/cmi_format.cmo typing/env.cmo \
-  typing/typedtree.cmo typing/printtyped.cmo typing/ctype.cmo \
-  typing/printtyp.cmo typing/includeclass.cmo \
-  typing/mtype.cmo typing/includecore.cmo \
-  typing/includemod.cmo typing/typetexp.cmo typing/parmatch.cmo \
-  typing/cmt_format.cmo typing/stypes.cmo typing/typecore.cmo \
-  typing/typedecl.cmo typing/typeclass.cmo \
-  typing/typemod.cmo
-
-COMP=bytecomp/lambda.cmo bytecomp/printlambda.cmo \
-  bytecomp/typeopt.cmo bytecomp/switch.cmo bytecomp/matching.cmo \
-  bytecomp/translobj.cmo bytecomp/translcore.cmo \
-  bytecomp/translclass.cmo bytecomp/translmod.cmo \
-  bytecomp/simplif.cmo bytecomp/runtimedef.cmo \
-  driver/pparse.cmo driver/main_args.cmo
-
-COMMON=$(UTILS) $(PARSING) $(TYPING) $(COMP)
-
-BYTECOMP=bytecomp/meta.cmo bytecomp/instruct.cmo bytecomp/bytegen.cmo \
-  bytecomp/printinstr.cmo bytecomp/opcodes.cmo bytecomp/emitcode.cmo \
-  bytecomp/bytesections.cmo bytecomp/dll.cmo bytecomp/symtable.cmo \
-  bytecomp/bytelink.cmo bytecomp/bytelibrarian.cmo bytecomp/bytepackager.cmo \
-  driver/errors.cmo driver/compile.cmo
-
-ASMCOMP=asmcomp/arch.cmo asmcomp/debuginfo.cmo \
-  asmcomp/cmm.cmo asmcomp/printcmm.cmo \
-  asmcomp/reg.cmo asmcomp/mach.cmo asmcomp/proc.cmo \
-  asmcomp/clambda.cmo asmcomp/printclambda.cmo asmcomp/compilenv.cmo \
-  asmcomp/closure.cmo asmcomp/cmmgen.cmo \
-  asmcomp/printmach.cmo asmcomp/selectgen.cmo asmcomp/selection.cmo \
-  asmcomp/comballoc.cmo asmcomp/liveness.cmo \
-  asmcomp/spill.cmo asmcomp/split.cmo \
-  asmcomp/interf.cmo asmcomp/coloring.cmo \
-  asmcomp/reloadgen.cmo asmcomp/reload.cmo \
-  asmcomp/printlinear.cmo asmcomp/linearize.cmo \
-  asmcomp/schedgen.cmo asmcomp/scheduling.cmo \
-  asmcomp/emitaux.cmo asmcomp/emit.cmo asmcomp/asmgen.cmo \
-  asmcomp/asmlink.cmo asmcomp/asmlibrarian.cmo asmcomp/asmpackager.cmo \
-  driver/opterrors.cmo driver/optcompile.cmo
-
-TOPLEVEL=toplevel/genprintval.cmo toplevel/toploop.cmo \
-  toplevel/trace.cmo toplevel/topdirs.cmo toplevel/topmain.cmo
-
-BYTESTART=driver/main.cmo
-
-OPTSTART=driver/optmain.cmo
-
-TOPLEVELSTART=toplevel/topstart.cmo
-
-NATTOPOBJS=$(UTILS) $(PARSING) $(TYPING) $(COMP) $(ASMCOMP) \
-  toplevel/genprintval.cmo toplevel/opttoploop.cmo toplevel/opttopdirs.cmo \
-  toplevel/opttopmain.cmo toplevel/opttopstart.cmo
-
-PERVASIVES=$(STDLIB_MODULES) outcometree topdirs toploop
-
-# For users who don't read the INSTALL file
-defaultentry:
-	@echo "Please refer to the installation instructions in file INSTALL."
-	@echo "If you've just unpacked the distribution, something like"
-	@echo "	./configure"
-	@echo "	make world"
-	@echo "	make opt"
-	@echo "	make install"
-	@echo "should work.  But see the file INSTALL for more details."
-
-# Recompile the system using the bootstrap compiler
-all: runtime ocamlc ocamllex ocamlyacc ocamltools library ocaml \
-  otherlibraries ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc
-
-# Compile everything the first time
-world:
-	$(MAKE) coldstart
-	$(MAKE) all
-
-# Compile also native code compiler and libraries, fast
-world.opt:
-	$(MAKE) coldstart
-	$(MAKE) opt.opt
-	$(MAKE) ocamltoolsopt
-
-# Hard bootstrap how-to:
-# (only necessary in some cases, for example if you remove some primitive)
-#
-# make coreboot     [old system -- you were in a stable state]
-# <change the source>
-# make core         [cross-compiler]
-# make partialclean [if you get "inconsistent assumptions"]
-# <debug your changes>
-# make core         [cross-compiler]
-# make coreboot     [new system -- now you are in a stable state]
-
-# Core bootstrapping cycle
-coreboot:
-# Save the original bootstrap compiler
-	$(MAKE) backup
-# Promote the new compiler but keep the old runtime
-# This compiler runs on boot/ocamlrun and produces bytecode for
-# byterun/ocamlrun
-	$(MAKE) promote-cross
-# Rebuild ocamlc and ocamllex (run on byterun/ocamlrun)
-	$(MAKE) partialclean
-	$(MAKE) ocamlc ocamllex ocamltools
-# Rebuild the library (using byterun/ocamlrun ./ocamlc)
-	$(MAKE) library-cross
-# Promote the new compiler and the new runtime
-	$(MAKE) promote
-# Rebuild the core system
-	$(MAKE) partialclean
-	$(MAKE) core
-# Check if fixpoint reached
-	$(MAKE) compare
-
-# Bootstrap and rebuild the whole system.
-# The compilation of ocaml will fail if the runtime has changed.
-# Never mind, just do make bootstrap to reach fixpoint again.
-bootstrap:
-	$(MAKE) coreboot
-	$(MAKE) all
-	$(MAKE) compare
-
-LIBFILES=stdlib.cma std_exit.cmo *.cmi camlheader
-
-# Start up the system from the distribution compiler
-coldstart:
-	cd byterun; $(MAKE) all
-	cp byterun/ocamlrun$(EXE) boot/ocamlrun$(EXE)
-	cd yacc; $(MAKE) all
-	cp yacc/ocamlyacc$(EXE) boot/ocamlyacc$(EXE)
-	cd stdlib; $(MAKE) COMPILER=../boot/ocamlc all
-	cd stdlib; cp $(LIBFILES) ../boot
-	if test -f boot/libcamlrun.a; then :; else \
-	  ln -s ../byterun/libcamlrun.a boot/libcamlrun.a; fi
-	if test -d stdlib/caml; then :; else \
-	  ln -s ../byterun stdlib/caml; fi
-
-# Build the core system: the minimum needed to make depend and bootstrap
-core: coldstart ocamlc ocamllex ocamlyacc ocamltools library
-
-# Recompile the core system using the bootstrap compiler
-coreall: ocamlc ocamllex ocamlyacc ocamltools library
-
-# Save the current bootstrap compiler
-MAXSAVED=boot/Saved/Saved.prev/Saved.prev/Saved.prev/Saved.prev/Saved.prev
-backup:
-	if test -d boot/Saved; then : ; else mkdir boot/Saved; fi
-	if test -d $(MAXSAVED); then rm -r $(MAXSAVED); else : ; fi
-	mv boot/Saved boot/Saved.prev
-	mkdir boot/Saved
-	mv boot/Saved.prev boot/Saved/Saved.prev
-	cp boot/ocamlrun$(EXE) boot/Saved
-	mv boot/ocamlc boot/ocamllex boot/ocamlyacc$(EXE) boot/ocamldep \
-	   boot/Saved
-	cd boot; cp $(LIBFILES) Saved
-
-# Promote the newly compiled system to the rank of cross compiler
-# (Runs on the old runtime, produces code for the new runtime)
-promote-cross:
-	cp ocamlc boot/ocamlc
-	cp lex/ocamllex boot/ocamllex
-	cp yacc/ocamlyacc$(EXE) boot/ocamlyacc$(EXE)
-	cp tools/ocamldep boot/ocamldep
-	cd stdlib; cp $(LIBFILES) ../boot
-
-# Promote the newly compiled system to the rank of bootstrap compiler
-# (Runs on the new runtime, produces code for the new runtime)
-promote: promote-cross
-	cp byterun/ocamlrun$(EXE) boot/ocamlrun$(EXE)
-
-# Restore the saved bootstrap compiler if a problem arises
-restore:
-	mv boot/Saved/* boot
-	rmdir boot/Saved
-	mv boot/Saved.prev boot/Saved
-
-# Check if fixpoint reached
-compare:
-	@if cmp boot/ocamlc ocamlc && cmp boot/ocamllex lex/ocamllex \
-	    && cmp boot/ocamldep tools/ocamldep; \
-	then echo "Fixpoint reached, bootstrap succeeded."; \
-	else echo "Fixpoint not reached, try one more bootstrapping cycle."; \
-	fi
-
-# Remove old bootstrap compilers
-cleanboot:
-	rm -rf boot/Saved/Saved.prev/*
-
-# Compile the native-code compiler
-opt-core:
-	$(MAKE) runtimeopt
-	$(MAKE) ocamlopt
-	$(MAKE) libraryopt
-
-opt:
-	$(MAKE) runtimeopt
-	$(MAKE) ocamlopt
-	$(MAKE) libraryopt
-	$(MAKE) otherlibrariesopt
-	$(MAKE) ocamltoolsopt
-	$(MAKE) ocamlbuildlib.native
-
-# Native-code versions of the tools
-opt.opt: checkstack runtime core ocaml opt-core ocamlc.opt otherlibraries \
-	 $(DEBUGGER) ocamldoc ocamlbuild.byte $(CAMLP4OUT) \
-	 ocamlopt.opt otherlibrariesopt ocamllex.opt ocamltoolsopt.opt \
-	 ocamldoc.opt ocamlbuild.native $(CAMLP4OPT)
-
-base.opt: checkstack runtime core ocaml opt-core ocamlc.opt otherlibraries \
-	 ocamlbuild.byte $(CAMLP4OUT) $(DEBUGGER) ocamldoc ocamlopt.opt \
-	 otherlibrariesopt
-
-# Installation
-
-COMPLIBDIR=$(LIBDIR)/compiler-libs
-
-install:
-	if test -d $(BINDIR); then : ; else $(MKDIR) $(BINDIR); fi
-	if test -d $(LIBDIR); then : ; else $(MKDIR) $(LIBDIR); fi
-	if test -d $(STUBLIBDIR); then : ; else $(MKDIR) $(STUBLIBDIR); fi
-	if test -d $(COMPLIBDIR); then : ; else $(MKDIR) $(COMPLIBDIR); fi
-	if test -d $(MANDIR)/man$(MANEXT); then : ; \
-	  else $(MKDIR) $(MANDIR)/man$(MANEXT); fi
-	cp VERSION $(LIBDIR)/
-	cd $(LIBDIR); rm -f dllbigarray.so dlllabltk.so dllnums.so \
-	  dllthreads.so dllunix.so dllgraphics.so dllstr.so \
-	  dlltkanim.so
-	cd byterun; $(MAKE) install
-	cp ocamlc $(BINDIR)/ocamlc$(EXE)
-	cp ocaml $(BINDIR)/ocaml$(EXE)
-	cd stdlib; $(MAKE) install
-	cp lex/ocamllex $(BINDIR)/ocamllex$(EXE)
-	cp yacc/ocamlyacc$(EXE) $(BINDIR)/ocamlyacc$(EXE)
-	cp utils/*.cmi parsing/*.cmi typing/*.cmi bytecomp/*.cmi driver/*.cmi toplevel/*.cmi $(COMPLIBDIR)
-	cp compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma compilerlibs/ocamltoplevel.cma $(BYTESTART) $(TOPLEVELSTART) $(COMPLIBDIR)
-	cp expunge $(LIBDIR)/expunge$(EXE)
-	cp toplevel/topdirs.cmi $(LIBDIR)
-	cd tools; $(MAKE) install
-	-cd man; $(MAKE) install
-	for i in $(OTHERLIBRARIES); do \
-	  (cd otherlibs/$$i; $(MAKE) install) || exit $$?; \
-	done
-	cd ocamldoc; $(MAKE) install
-	if test -f ocamlopt; then $(MAKE) installopt; else :; fi
-	if test -f debugger/ocamldebug; then (cd debugger; $(MAKE) install); \
-	   else :; fi
-	cp config/Makefile $(LIBDIR)/Makefile.config
-	BINDIR=$(BINDIR) LIBDIR=$(LIBDIR) PREFIX=$(PREFIX) \
-	  ./build/partial-install.sh
-
-# Installation of the native-code compiler
-installopt:
-	cd asmrun; $(MAKE) install
-	cp ocamlopt $(BINDIR)/ocamlopt$(EXE)
-	cd stdlib; $(MAKE) installopt
-	cp asmcomp/*.cmi $(COMPLIBDIR)
-	cp compilerlibs/ocamloptcomp.cma $(OPTSTART) $(COMPLIBDIR)
-	cd ocamldoc; $(MAKE) installopt
-	for i in $(OTHERLIBRARIES); \
-	  do (cd otherlibs/$$i; $(MAKE) installopt) || exit $$?; done
-	if test -f ocamlopt.opt ; then $(MAKE) installoptopt; fi
-	cd tools; $(MAKE) installopt
-
-installoptopt:
-	cp ocamlc.opt $(BINDIR)/ocamlc.opt$(EXE)
-	cp ocamlopt.opt $(BINDIR)/ocamlopt.opt$(EXE)
-	cp lex/ocamllex.opt $(BINDIR)/ocamllex.opt$(EXE)
-	cp compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlcommon.a \
-           compilerlibs/ocamlbytecomp.cmxa compilerlibs/ocamlbytecomp.a \
-           compilerlibs/ocamloptcomp.cmxa compilerlibs/ocamloptcomp.a \
-           $(BYTESTART:.cmo=.cmx) $(BYTESTART:.cmo=.o) \
-           $(OPTSTART:.cmo=.cmx) $(OPTSTART:.cmo=.o) \
-           $(COMPLIBDIR)
-	cd $(COMPLIBDIR) && $(RANLIB) ocamlcommon.a ocamlbytecomp.a ocamloptcomp.a
-
-clean:: partialclean
-
-# Shared parts of the system
-
-compilerlibs/ocamlcommon.cma: $(COMMON)
-	$(CAMLC) -a -o $@ $(COMMON)
-partialclean::
-	rm -f compilerlibs/ocamlcommon.cma
-
-# The bytecode compiler
-
-compilerlibs/ocamlbytecomp.cma: $(BYTECOMP)
-	$(CAMLC) -a -o $@ $(BYTECOMP)
-partialclean::
-	rm -f compilerlibs/ocamlbytecomp.cma
-
-ocamlc: compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma $(BYTESTART)
-	$(CAMLC) $(LINKFLAGS) -o ocamlc \
-           compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma $(BYTESTART)
-	@sed -e 's|@compiler@|$$topdir/boot/ocamlrun $$topdir/ocamlc|' \
-	  driver/ocamlcomp.sh.in > ocamlcomp.sh
-	@chmod +x ocamlcomp.sh
-
-# The native-code compiler
-
-compilerlibs/ocamloptcomp.cma: $(ASMCOMP)
-	$(CAMLC) -a -o $@ $(ASMCOMP)
-partialclean::
-	rm -f compilerlibs/ocamloptcomp.cma
-
-ocamlopt: compilerlibs/ocamlcommon.cma compilerlibs/ocamloptcomp.cma $(OPTSTART)
-	$(CAMLC) $(LINKFLAGS) -o ocamlopt \
-          compilerlibs/ocamlcommon.cma compilerlibs/ocamloptcomp.cma $(OPTSTART)
-	@sed -e 's|@compiler@|$$topdir/boot/ocamlrun $$topdir/ocamlopt|' \
-	  driver/ocamlcomp.sh.in > ocamlcompopt.sh
-	@chmod +x ocamlcompopt.sh
-
-partialclean::
-	rm -f ocamlopt ocamlcompopt.sh
-
-# The toplevel
-
-compilerlibs/ocamltoplevel.cma: $(TOPLEVEL)
-	$(CAMLC) -a -o $@ $(TOPLEVEL)
-partialclean::
-	rm -f compilerlibs/ocamltoplevel.cma
-
-ocaml: compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma compilerlibs/ocamltoplevel.cma $(TOPLEVELSTART) expunge
-	$(CAMLC) $(LINKFLAGS) -linkall -o ocaml.tmp \
-          compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma \
-          compilerlibs/ocamltoplevel.cma $(TOPLEVELSTART)
-	- $(CAMLRUN) ./expunge ocaml.tmp ocaml $(PERVASIVES)
-	rm -f ocaml.tmp
-
-partialclean::
-	rm -f ocaml
-
-# The native toplevel
-
-ocamlnat: ocamlopt otherlibs/dynlink/dynlink.cmxa $(NATTOPOBJS:.cmo=.cmx)
-	$(CAMLOPT) $(LINKFLAGS) otherlibs/dynlink/dynlink.cmxa -o ocamlnat \
-	           $(NATTOPOBJS:.cmo=.cmx) -linkall
-
-toplevel/opttoploop.cmx: otherlibs/dynlink/dynlink.cmxa
-
-otherlibs/dynlink/dynlink.cmxa: otherlibs/dynlink/natdynlink.ml
-	cd otherlibs/dynlink && $(MAKE) allopt
-
-# The configuration file
-
-utils/config.ml: utils/config.mlp config/Makefile
-	@rm -f utils/config.ml
-	sed -e 's|%%LIBDIR%%|$(LIBDIR)|' \
-	    -e 's|%%BYTERUN%%|$(BINDIR)/ocamlrun|' \
-	    -e 's|%%CCOMPTYPE%%|cc|' \
-	    -e 's|%%BYTECC%%|$(BYTECC) $(BYTECCCOMPOPTS) $(SHAREDCCCOMPOPTS)|' \
-	    -e 's|%%NATIVECC%%|$(NATIVECC) $(NATIVECCCOMPOPTS)|' \
-	    -e 's|%%PACKLD%%|$(PACKLD)|' \
-	    -e 's|%%BYTECCLIBS%%|$(BYTECCLIBS)|' \
-	    -e 's|%%NATIVECCLIBS%%|$(NATIVECCLIBS)|' \
-	    -e 's|%%RANLIBCMD%%|$(RANLIBCMD)|' \
-	    -e 's|%%ARCMD%%|$(ARCMD)|' \
-	    -e 's|%%CC_PROFILE%%|$(CC_PROFILE)|' \
-	    -e 's|%%ARCH%%|$(ARCH)|' \
-	    -e 's|%%MODEL%%|$(MODEL)|' \
-	    -e 's|%%SYSTEM%%|$(SYSTEM)|' \
-	    -e 's|%%EXT_OBJ%%|.o|' \
-	    -e 's|%%EXT_ASM%%|.s|' \
-	    -e 's|%%EXT_LIB%%|.a|' \
-	    -e 's|%%EXT_DLL%%|.so|' \
-	    -e 's|%%SYSTHREAD_SUPPORT%%|$(SYSTHREAD_SUPPORT)|' \
-	    -e 's|%%ASM%%|$(ASM)|' \
-	    -e 's|%%ASM_CFI_SUPPORTED%%|$(ASM_CFI_SUPPORTED)|' \
-	    -e 's|%%MKDLL%%|$(MKDLL)|' \
-	    -e 's|%%MKEXE%%|$(MKEXE)|' \
-	    -e 's|%%MKMAINDLL%%|$(MKMAINDLL)|' \
-	    utils/config.mlp > utils/config.ml
-	@chmod -w utils/config.ml
-
-partialclean::
-	rm -f utils/config.ml
-
-beforedepend:: utils/config.ml
-
-# The parser
-
-parsing/parser.mli parsing/parser.ml: parsing/parser.mly
-	$(CAMLYACC) $(YACCFLAGS) parsing/parser.mly
-
-partialclean::
-	rm -f parsing/parser.mli parsing/parser.ml parsing/parser.output
-
-beforedepend:: parsing/parser.mli parsing/parser.ml
-
-# The lexer
-
-parsing/lexer.ml: parsing/lexer.mll
-	$(CAMLLEX) parsing/lexer.mll
-
-partialclean::
-	rm -f parsing/lexer.ml
-
-beforedepend:: parsing/lexer.ml
-
-# Shared parts of the system compiled with the native-code compiler
-
-compilerlibs/ocamlcommon.cmxa: $(COMMON:.cmo=.cmx)
-	$(CAMLOPT) -a -o $@ $(COMMON:.cmo=.cmx)
-partialclean::
-	rm -f compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlcommon.a
-
-# The bytecode compiler compiled with the native-code compiler
-
-compilerlibs/ocamlbytecomp.cmxa: $(BYTECOMP:.cmo=.cmx)
-	$(CAMLOPT) -a -o $@ $(BYTECOMP:.cmo=.cmx)
-partialclean::
-	rm -f compilerlibs/ocamlbytecomp.cmxa compilerlibs/ocamlbytecomp.a
-
-ocamlc.opt: compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlbytecomp.cmxa $(BYTESTART:.cmo=.cmx)
-	$(CAMLOPT) $(LINKFLAGS) -ccopt "$(BYTECCLINKOPTS)" -o ocamlc.opt \
-          compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlbytecomp.cmxa \
-          $(BYTESTART:.cmo=.cmx) -cclib "$(BYTECCLIBS)"
-	@sed -e 's|@compiler@|$$topdir/ocamlc.opt|' \
-	  driver/ocamlcomp.sh.in > ocamlcomp.sh
-	@chmod +x ocamlcomp.sh
-
-partialclean::
-	rm -f ocamlc.opt
-
-# The native-code compiler compiled with itself
-
-compilerlibs/ocamloptcomp.cmxa: $(ASMCOMP:.cmo=.cmx)
-	$(CAMLOPT) -a -o $@ $(ASMCOMP:.cmo=.cmx)
-partialclean::
-	rm -f compilerlibs/ocamloptcomp.cmxa compilerlibs/ocamloptcomp.a
-
-ocamlopt.opt: compilerlibs/ocamlcommon.cmxa compilerlibs/ocamloptcomp.cmxa $(OPTSTART:.cmo=.cmx)
-	$(CAMLOPT) $(LINKFLAGS) -o ocamlopt.opt \
-           compilerlibs/ocamlcommon.cmxa compilerlibs/ocamloptcomp.cmxa \
-           $(OPTSTART:.cmo=.cmx)
-	@sed -e 's|@compiler@|$$topdir/ocamlopt.opt|' \
-	  driver/ocamlcomp.sh.in > ocamlcompopt.sh
-	@chmod +x ocamlcompopt.sh
-
-partialclean::
-	rm -f ocamlopt.opt
-
-$(COMMON:.cmo=.cmx) $(BYTECOMP:.cmo=.cmx) $(ASMCOMP:.cmo=.cmx): ocamlopt
-
-# The numeric opcodes
-
-bytecomp/opcodes.ml: byterun/instruct.h
-	sed -n -e '/^enum/p' -e 's/,//g' -e '/^  /p' byterun/instruct.h | \
-	awk -f tools/make-opcodes > bytecomp/opcodes.ml
-
-partialclean::
-	rm -f bytecomp/opcodes.ml
-
-beforedepend:: bytecomp/opcodes.ml
-
-# The predefined exceptions and primitives
-
-byterun/primitives:
-	cd byterun; $(MAKE) primitives
-
-bytecomp/runtimedef.ml: byterun/primitives byterun/fail.h
-	(echo 'let builtin_exceptions = [|'; \
-	 sed -n -e 's|.*/\* \("[A-Za-z_]*"\) \*/$$|  \1;|p' byterun/fail.h | \
-	 sed -e '$$s/;$$//'; \
-	 echo '|]'; \
-	 echo 'let builtin_primitives = [|'; \
-	 sed -e 's/.*/  "&";/' -e '$$s/;$$//' byterun/primitives; \
-	 echo '|]') > bytecomp/runtimedef.ml
-
-partialclean::
-	rm -f bytecomp/runtimedef.ml
-
-beforedepend:: bytecomp/runtimedef.ml
-
-# Choose the right machine-dependent files
-
-asmcomp/arch.ml: asmcomp/$(ARCH)/arch.ml
-	ln -s $(ARCH)/arch.ml asmcomp/arch.ml
-
-partialclean::
-	rm -f asmcomp/arch.ml
-
-beforedepend:: asmcomp/arch.ml
-
-asmcomp/proc.ml: asmcomp/$(ARCH)/proc.ml
-	ln -s $(ARCH)/proc.ml asmcomp/proc.ml
-
-partialclean::
-	rm -f asmcomp/proc.ml
-
-beforedepend:: asmcomp/proc.ml
-
-asmcomp/selection.ml: asmcomp/$(ARCH)/selection.ml
-	ln -s $(ARCH)/selection.ml asmcomp/selection.ml
-
-partialclean::
-	rm -f asmcomp/selection.ml
-
-beforedepend:: asmcomp/selection.ml
-
-asmcomp/reload.ml: asmcomp/$(ARCH)/reload.ml
-	ln -s $(ARCH)/reload.ml asmcomp/reload.ml
-
-partialclean::
-	rm -f asmcomp/reload.ml
-
-beforedepend:: asmcomp/reload.ml
-
-asmcomp/scheduling.ml: asmcomp/$(ARCH)/scheduling.ml
-	ln -s $(ARCH)/scheduling.ml asmcomp/scheduling.ml
-
-partialclean::
-	rm -f asmcomp/scheduling.ml
-
-beforedepend:: asmcomp/scheduling.ml
-
-# Preprocess the code emitters
-
-asmcomp/emit.ml: asmcomp/$(ARCH)/emit.mlp tools/cvt_emit
-	$(CAMLRUN) tools/cvt_emit < asmcomp/$(ARCH)/emit.mlp > asmcomp/emit.ml \
-	|| { rm -f asmcomp/emit.ml; exit 2; }
-
-partialclean::
-	rm -f asmcomp/emit.ml
-
-beforedepend:: asmcomp/emit.ml
-
-tools/cvt_emit: tools/cvt_emit.mll
-	cd tools; \
-	$(MAKE) CAMLC="../$(CAMLRUN) ../boot/ocamlc -I ../stdlib" cvt_emit
-
-# The "expunge" utility
-
-expunge: compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma toplevel/expunge.cmo
-	$(CAMLC) $(LINKFLAGS) -o expunge \
-          compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma toplevel/expunge.cmo
-
-partialclean::
-	rm -f expunge
-
-# The runtime system for the bytecode compiler
-
-runtime:
-	cd byterun; $(MAKE) all
-	if test -f stdlib/libcamlrun.a; then :; else \
-	  ln -s ../byterun/libcamlrun.a stdlib/libcamlrun.a; fi
-
-clean::
-	cd byterun; $(MAKE) clean
-	rm -f stdlib/libcamlrun.a
-	rm -f stdlib/caml
-
-alldepend::
-	cd byterun; $(MAKE) depend
-
-# The runtime system for the native-code compiler
-
-runtimeopt: makeruntimeopt
-	cp asmrun/libasmrun.a stdlib/libasmrun.a
-
-makeruntimeopt:
-	cd asmrun; $(MAKE) all
-
-clean::
-	cd asmrun; $(MAKE) clean
-	rm -f stdlib/libasmrun.a
-
-alldepend::
-	cd asmrun; $(MAKE) depend
-
-# The library
-
-library: ocamlc
-	cd stdlib; $(MAKE) all
-
-library-cross:
-	cd stdlib; $(MAKE) RUNTIME=../byterun/ocamlrun all
-
-libraryopt:
-	cd stdlib; $(MAKE) allopt
-
-partialclean::
-	cd stdlib; $(MAKE) clean
-
-alldepend::
-	cd stdlib; $(MAKE) depend
-
-# The lexer and parser generators
-
-ocamllex: ocamlyacc ocamlc
-	cd lex; $(MAKE) all
-
-ocamllex.opt: ocamlopt
-	cd lex; $(MAKE) allopt
-
-partialclean::
-	cd lex; $(MAKE) clean
-
-alldepend::
-	cd lex; $(MAKE) depend
-
-ocamlyacc:
-	cd yacc; $(MAKE) all
-
-clean::
-	cd yacc; $(MAKE) clean
-
-# Tools
-
-ocamltools: ocamlc ocamlyacc ocamllex asmcomp/cmx_format.cmi
-	cd tools; $(MAKE) all
-
-ocamltoolsopt: ocamlopt
-	cd tools; $(MAKE) opt
-
-ocamltoolsopt.opt: ocamlc.opt ocamlyacc ocamllex asmcomp/cmx_format.cmi
-	cd tools; $(MAKE) opt.opt
-
-partialclean::
-	cd tools; $(MAKE) clean
-
-alldepend::
-	cd tools; $(MAKE) depend
-
-# OCamldoc
-
-ocamldoc: ocamlc ocamlyacc ocamllex otherlibraries
-	cd ocamldoc && $(MAKE) all
-
-ocamldoc.opt: ocamlc.opt ocamlyacc ocamllex
-	cd ocamldoc && $(MAKE) opt.opt
-
-partialclean::
-	cd ocamldoc && $(MAKE) clean
-
-alldepend::
-	cd ocamldoc && $(MAKE) depend
-
-# The extra libraries
-
-otherlibraries: ocamltools
-	for i in $(OTHERLIBRARIES); do \
-	  (cd otherlibs/$$i; $(MAKE) RUNTIME=$(RUNTIME) all) || exit $$?; \
-	done
-
-otherlibrariesopt:
-	for i in $(OTHERLIBRARIES); do \
-	  (cd otherlibs/$$i; $(MAKE) allopt) || exit $$?; \
-	done
-
-partialclean::
-	for i in $(OTHERLIBRARIES); do \
-	  (cd otherlibs/$$i; $(MAKE) partialclean); \
-	done
-
-clean::
-	for i in $(OTHERLIBRARIES); do (cd otherlibs/$$i; $(MAKE) clean); done
-
-alldepend::
-	for i in $(OTHERLIBRARIES); do (cd otherlibs/$$i; $(MAKE) depend); done
-
-# The replay debugger
-
-ocamldebugger: ocamlc ocamlyacc ocamllex otherlibraries
-	cd debugger; $(MAKE) all
-
-partialclean::
-	cd debugger; $(MAKE) clean
-
-alldepend::
-	cd debugger; $(MAKE) depend
-
-# Camlp4
-
-camlp4out: ocamlc ocamlbuild.byte
-	./build/camlp4-byte-only.sh
-
-camlp4opt: ocamlopt otherlibrariesopt ocamlbuild-mixed-boot ocamlbuild.native
-	./build/camlp4-native-only.sh
-
-# Ocamlbuild
-
-ocamlbuild.byte: ocamlc ocamlbuild-mixed-boot
-	./build/ocamlbuild-byte-only.sh
-
-ocamlbuild.native: ocamlopt ocamlbuild-mixed-boot
-	./build/ocamlbuild-native-only.sh
-ocamlbuildlib.native: ocamlopt ocamlbuild-mixed-boot
-	./build/ocamlbuildlib-native-only.sh
-
-ocamlbuild-mixed-boot: ocamlc
-	./build/mixed-boot.sh
-	touch ocamlbuild-mixed-boot
-
-partialclean::
-	rm -rf _build ocamlbuild-mixed-boot
-
-# Check that the stack limit is reasonable.
-
-checkstack:
-	@if $(BYTECC) -o tools/checkstack tools/checkstack.c; \
-	  then tools/checkstack; \
-	  else :; \
-	fi
-	@rm -f tools/checkstack
-
-# Make clean in the test suite
-
-clean::
-	cd testsuite; $(MAKE) clean
-
-# Make MacOS X package
-
-package-macosx:
-	sudo rm -rf package-macosx/root
-	$(MAKE) PREFIX="`pwd`"/package-macosx/root install
-	tools/make-package-macosx
-	sudo rm -rf package-macosx/root
-
-clean::
-	rm -rf package-macosx/*.pkg package-macosx/*.dmg
-
-# Default rules
-
-.SUFFIXES: .ml .mli .cmo .cmi .cmx
-
-.ml.cmo:
-	$(CAMLC) $(COMPFLAGS) -c $<
-
-.mli.cmi:
-	$(CAMLC) $(COMPFLAGS) -c $<
-
-.ml.cmx:
-	$(CAMLOPT) $(COMPFLAGS) -c $<
-
-partialclean::
-	for d in utils parsing typing bytecomp asmcomp driver toplevel tools; \
-	  do rm -f $$d/*.cm[iox] $$d/*.annot $$d/*.[so] $$d/*~; done
-	rm -f *~
-
-depend: beforedepend
-	(for d in utils parsing typing bytecomp asmcomp driver toplevel; \
-	 do $(CAMLDEP) $(DEPFLAGS) $$d/*.mli $$d/*.ml; \
-	 done) > .depend
-
-alldepend:: depend
-
-distclean:
-	./build/distclean.sh
-
-.PHONY: all backup bootstrap camlp4opt camlp4out checkstack clean
-.PHONY: partialclean beforedepend alldepend cleanboot coldstart
-.PHONY: compare core coreall
-.PHONY: coreboot defaultentry depend distclean install installopt
-.PHONY: library library-cross libraryopt ocamlbuild-mixed-boot
-.PHONY: ocamlbuild.byte ocamlbuild.native ocamldebugger ocamldoc
-.PHONY: ocamldoc.opt ocamllex ocamllex.opt ocamltools ocamltoolsopt
-.PHONY: ocamltoolsopt.opt ocamlyacc opt-core opt opt.opt otherlibraries
-.PHONY: otherlibrariesopt package-macosx promote promote-cross
-.PHONY: restore runtime runtimeopt makeruntimeopt world world.opt
-
-include .depend
diff -urN ocaml-4.00-ios/asmcomp/arm/emit.mlp ocaml-4.00/asmcomp/arm/emit.mlp
--- ocaml-4.00-ios/asmcomp/arm/emit.mlp	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/asmcomp/arm/emit.mlp	2012-06-06 01:55:41.000000000 +0400
@@ -32,20 +32,25 @@
 (* Output a label *)
 
 let emit_label lbl =
-  emit_string "L"; emit_int lbl
+  emit_string ".L"; emit_int lbl
 
 let emit_data_label lbl =
-  emit_string "Ld"; emit_int lbl
+  emit_string ".Ld"; emit_int lbl
 
 (* Symbols *)
 
 let emit_symbol s =
-	emit_string "_"; Emitaux.emit_symbol '$' s
+  Emitaux.emit_symbol '$' s
 
 let emit_call s =
-  `bl	{emit_symbol s}`
-
-let emit_jump s = `b	{emit_symbol s}`
+  if !Clflags.dlcode || !pic_code
+  then `bl	{emit_symbol s}(PLT)`
+  else `bl	{emit_symbol s}`
+
+let emit_jump s =
+  if !Clflags.dlcode || !pic_code
+  then `b	{emit_symbol s}(PLT)`
+  else `b	{emit_symbol s}`
 
 (* Output a pseudo-register *)
 
@@ -745,10 +750,8 @@
           (* The Thumb-2 TBH instruction supports only forward branches,
              so we need to generate appropriate trampolines for all labels
              that appear before this switch instruction (PR#5623) *)
-					let lbl = new_label () in
           let tramtbl = Array.copy jumptbl in
           `	tbh	[pc, {emit_reg i.arg.(0)}, lsl #1]\n`;
-					`{emit_label lbl}:`;
           for j = 0 to Array.length tramtbl - 1 do
             let rec label i =
               match i.desc with
@@ -756,7 +759,7 @@
               | Llabel lbl when lbl = tramtbl.(j) -> lbl
               | _ -> label i.next in
             tramtbl.(j) <- label i.next;
-            `	.short	({emit_label tramtbl.(j)}-{emit_label lbl})/2\n`
+            `	.short	({emit_label tramtbl.(j)}-.)/2+{emit_int j}\n`
           done;
           (* Generate the necessary trampolines *)
           for j = 0 to Array.length tramtbl - 1 do
@@ -844,13 +847,13 @@
   call_gc_sites := [];
   bound_error_sites := [];
   `	.text\n`;
-  `	.globl	{emit_symbol fundecl.fun_name}\n`;
   `	.align	2\n`;
+  `	.globl	{emit_symbol fundecl.fun_name}\n`;
   if !arch > ARMv6 && !thumb then
     `	.thumb\n`
   else
     `	.arm\n`;
-	`  .thumb_func {emit_symbol fundecl.fun_name}\n`;
+  `	.type	{emit_symbol fundecl.fun_name}, %function\n`;
   `{emit_symbol fundecl.fun_name}:\n`;
   emit_debug_info fundecl.fun_dbg;
   cfi_startproc();
@@ -866,7 +869,9 @@
   emit_literals();
   List.iter emit_call_gc !call_gc_sites;
   List.iter emit_call_bound_error !bound_error_sites;
-  cfi_endproc()
+  cfi_endproc();
+  `	.type	{emit_symbol fundecl.fun_name}, %function\n`;
+  `	.size	{emit_symbol fundecl.fun_name}, .-{emit_symbol fundecl.fun_name}\n`
 
 (* Emission of data *)
 
@@ -895,7 +900,6 @@
 let begin_assembly() =
   reset_debug_info();
   `	.syntax	unified\n`;
-	(*
   begin match !arch with
   | ARMv4   -> `	.arch	armv4t\n`
   | ARMv5   -> `	.arch	armv5t\n`
@@ -909,7 +913,6 @@
   | VFPv3_D16 -> `	.fpu	vfpv3-d16\n`
   | VFPv3     -> `	.fpu	vfpv3\n`
   end;
-	*)
   `trap_ptr	.req	r8\n`;
   `alloc_ptr	.req	r10\n`;
   `alloc_limit	.req	r11\n`;
@@ -920,15 +923,13 @@
   let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
   `	.text\n`;
   `	.globl	{emit_symbol lbl_begin}\n`;
-  `{emit_symbol lbl_begin}:\n`;
-	` nop\n`
+  `{emit_symbol lbl_begin}:\n`
 
 let end_assembly () =
   let lbl_end = Compilenv.make_symbol (Some "code_end") in
   `	.text\n`;
   `	.globl	{emit_symbol lbl_end}\n`;
   `{emit_symbol lbl_end}:\n`;
-	` nop\n`;
   let lbl_end = Compilenv.make_symbol (Some "data_end") in
   `	.data\n`;
   `	.globl	{emit_symbol lbl_end}\n`;
@@ -939,7 +940,7 @@
   `{emit_symbol lbl}:\n`;
   emit_frames
     { efa_label = (fun lbl ->
-         (*              `	.type	{emit_label lbl}, %function\n`; *)
+                       `	.type	{emit_label lbl}, %function\n`;
                        `	.word	{emit_label lbl}\n`);
       efa_16 = (fun n -> `	.short	{emit_int n}\n`);
       efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
@@ -948,4 +949,12 @@
       efa_label_rel = (fun lbl ofs ->
                            `	.word	{emit_label lbl} - . + {emit_int32 ofs}\n`);
       efa_def_label = (fun lbl -> `{emit_label lbl}:\n`);
-      efa_string = (fun s -> emit_string_directive "	.asciz	" s) }
+      efa_string = (fun s -> emit_string_directive "	.asciz	" s) };
+  `	.type	{emit_symbol lbl}, %object\n`;
+  `	.size	{emit_symbol lbl}, .-{emit_symbol lbl}\n`;
+  begin match Config.system with
+    "linux_eabihf" | "linux_eabi" ->
+      (* Mark stack as non-executable *)
+      `	.section	.note.GNU-stack,\"\",%progbits\n`
+  | _ -> ()
+  end
diff -urN ocaml-4.00-ios/asmrun/arm.S ocaml-4.00/asmrun/arm.S
--- ocaml-4.00-ios/asmrun/arm.S	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/asmrun/arm.S	2012-04-26 23:18:00.000000000 +0400
@@ -17,27 +17,11 @@
 /* Asm part of the runtime system, ARM processor */
 /* Must be preprocessed by cpp */
 
-#if defined(SYS_solaris)
-#define CONCAT(a,b) a/**/b
-#else
-#define CONCAT(a,b) a##b
-#endif
-
-#if defined(SYS_linux_elf) || defined(SYS_bsd_elf) \
- || defined(SYS_solaris) || defined(SYS_beos) || defined(SYS_gnu)
-#define G(x) x
-#define LBL(x) CONCAT(.L,x)
-#else
-#define G(x) CONCAT(_,x)
-#define LBL(x) CONCAT(L,x)
-#endif
-
         .syntax unified
         .text
 #if defined(SYS_linux_eabihf)
-/*        .arch   armv7-a
+        .arch   armv7-a
         .fpu    vfpv3-d16
-*/        
         .thumb
 #elif defined(SYS_linux_eabi)
         .arch   armv4t
@@ -62,176 +46,204 @@
 alloc_ptr       .req    r10
 alloc_limit     .req    r11
 
+/* Support for profiling with gprof */
+
+#if defined(PROFILING) && (defined(SYS_linux_eabihf) || defined(SYS_linux_eabi))
+#define PROFILE \
+        push    {lr}; \
+        bl      __gnu_mcount_nc
+#else
+#define PROFILE
+#endif
+
 /* Allocation functions and GC interface */
 
-        .globl  G(caml_system__code_begin)
-G(caml_system__code_begin):
-				nop
+        .globl  caml_system__code_begin
+caml_system__code_begin:
         
         .align  2
-        .globl  G(caml_call_gc)
-				.thumb_func G(caml_call_gc)
-G(caml_call_gc):
+        .globl  caml_call_gc
+        .type caml_call_gc, %function
+caml_call_gc:
+        PROFILE
     /* Record return address */
-        ldr     r12, LBL(caml_last_return_address)
+        ldr     r12, =caml_last_return_address
         str     lr, [r12]
-LBL(caml_call_gc):
+.Lcaml_call_gc:
     /* Record lowest stack address */
-        ldr     r12, LBL(caml_bottom_of_stack)
+        ldr     r12, =caml_bottom_of_stack
         str     sp, [r12]
     /* Save caller floating-point registers on the stack */
         vpush   {d0-d7}
     /* Save integer registers and return address on the stack */
         push    {r0-r7,r12,lr}
     /* Store pointer to saved integer registers in caml_gc_regs */
-        ldr     r12, LBL(caml_gc_regs)
+        ldr     r12, =caml_gc_regs
         str     sp, [r12]
     /* Save current allocation pointer for debugging purposes */
-        ldr     alloc_limit, LBL(caml_young_ptr)
+        ldr     alloc_limit, =caml_young_ptr
         str     alloc_ptr, [alloc_limit]
     /* Save trap pointer in case an exception is raised during GC */
-        ldr     r12, LBL(caml_exception_pointer)
+        ldr     r12, =caml_exception_pointer
         str     trap_ptr, [r12]
     /* Call the garbage collector */
-        bl      G(caml_garbage_collection)
+        bl      caml_garbage_collection
     /* Restore integer registers and return address from the stack */
         pop     {r0-r7,r12,lr}
     /* Restore floating-point registers from the stack */
         vpop    {d0-d7}
     /* Reload new allocation pointer and limit */
     /* alloc_limit still points to caml_young_ptr */
-        ldr     r12, LBL(caml_young_limit)
+        ldr     r12, =caml_young_limit
         ldr     alloc_ptr, [alloc_limit]
         ldr     alloc_limit, [r12]
     /* Return to caller */
         bx      lr
+        .type   caml_call_gc, %function
+        .size   caml_call_gc, .-caml_call_gc
 
         .align  2
-        .globl  G(caml_alloc1)
-				.thumb_func G(caml_alloc1)
-G(caml_alloc1):
-LBL(caml_alloc1):
+        .globl  caml_alloc1
+        .type caml_alloc1, %function
+caml_alloc1:
+        PROFILE
+.Lcaml_alloc1:
         sub     alloc_ptr, alloc_ptr, 8
         cmp     alloc_ptr, alloc_limit
         bcc     1f
         bx      lr
 1:  /* Record return address */
-        ldr     r7, LBL(caml_last_return_address)
+        ldr     r7, =caml_last_return_address
         str     lr, [r7]
     /* Call GC (preserves r7) */
-        bl      LBL(caml_call_gc)
+        bl      .Lcaml_call_gc
     /* Restore return address */
         ldr     lr, [r7]
     /* Try again */
-        b       LBL(caml_alloc1)
+        b       .Lcaml_alloc1
+        .type   caml_alloc1, %function
+        .size   caml_alloc1, .-caml_alloc1
 
         .align  2
-        .globl  G(caml_alloc2)
-				.thumb_func G(caml_alloc2)
-G(caml_alloc2):
-LBL(caml_alloc2):
+        .globl  caml_alloc2
+        .type caml_alloc2, %function
+caml_alloc2:
+        PROFILE
+.Lcaml_alloc2:
         sub     alloc_ptr, alloc_ptr, 12
         cmp     alloc_ptr, alloc_limit
         bcc     1f
         bx      lr
 1:  /* Record return address */
-        ldr     r7, LBL(caml_last_return_address)
+        ldr     r7, =caml_last_return_address
         str     lr, [r7]
     /* Call GC (preserves r7) */
-        bl      LBL(caml_call_gc)
+        bl      .Lcaml_call_gc
     /* Restore return address */
         ldr     lr, [r7]
     /* Try again */
-        b       LBL(caml_alloc2)
+        b       .Lcaml_alloc2
+        .type   caml_alloc2, %function
+        .size   caml_alloc2, .-caml_alloc2
 
         .align  2
-        .globl  G(caml_alloc3)
-        .thumb_func  G(caml_alloc3)
-G(caml_alloc3):
-LBL(caml_alloc3):
+        .globl  caml_alloc3
+        .type caml_alloc3, %function
+caml_alloc3:
+        PROFILE
+.Lcaml_alloc3:
         sub     alloc_ptr, alloc_ptr, 16
         cmp     alloc_ptr, alloc_limit
         bcc     1f
         bx      lr
 1:  /* Record return address */
-        ldr     r7, LBL(caml_last_return_address)
+        ldr     r7, =caml_last_return_address
         str     lr, [r7]
     /* Call GC (preserves r7) */
-        bl      LBL(caml_call_gc)
+        bl      .Lcaml_call_gc
     /* Restore return address */
         ldr     lr, [r7]
     /* Try again */
-        b       LBL(caml_alloc3)
+        b       .Lcaml_alloc3
+        .type   caml_alloc3, %function
+        .size   caml_alloc3, .-caml_alloc3
 
         .align  2
-        .globl  G(caml_allocN)
-        .thumb_func  G(caml_allocN)
-G(caml_allocN):
-LBL(caml_allocN):
+        .globl  caml_allocN
+        .type caml_allocN, %function
+caml_allocN:
+        PROFILE
+.Lcaml_allocN:
         sub     alloc_ptr, alloc_ptr, r7
         cmp     alloc_ptr, alloc_limit
         bcc     1f
         bx      lr
 1:  /* Record return address */
-        ldr     r12, LBL(caml_last_return_address)
+        ldr     r12, =caml_last_return_address
         str     lr, [r12]
     /* Call GC (preserves r7) */
-        bl      LBL(caml_call_gc)
+        bl      .Lcaml_call_gc
     /* Restore return address */
-        ldr     r12, LBL(caml_last_return_address)
+        ldr     r12, =caml_last_return_address
         ldr     lr, [r12]
     /* Try again */
-        b       LBL(caml_allocN)
+        b       .Lcaml_allocN
+        .type   caml_allocN, %function
+        .size   caml_allocN, .-caml_allocN
 
 /* Call a C function from OCaml */
 /* Function to call is in r7 */
 
         .align  2
-        .globl  G(caml_c_call)
-        .thumb_func  G(caml_c_call)
-G(caml_c_call):
+        .globl  caml_c_call
+        .type caml_c_call, %function
+caml_c_call:
+        PROFILE
     /* Record lowest stack address and return address */
-        ldr     r5, LBL(caml_last_return_address)
-        ldr     r6, LBL(caml_bottom_of_stack)
+        ldr     r5, =caml_last_return_address
+        ldr     r6, =caml_bottom_of_stack
         str     lr, [r5]
         str     sp, [r6]
     /* Preserve return address in callee-save register r4 */
         mov     r4, lr
     /* Make the exception handler alloc ptr available to the C code */
-        ldr     r5, LBL(caml_young_ptr)
-        ldr     r6, LBL(caml_exception_pointer)
+        ldr     r5, =caml_young_ptr
+        ldr     r6, =caml_exception_pointer
         str     alloc_ptr, [r5]
         str     trap_ptr, [r6]
     /* Call the function */
         blx     r7
     /* Reload alloc ptr and alloc limit */
-        ldr     r6, LBL(caml_young_limit)
+        ldr     r6, =caml_young_limit
         ldr     alloc_ptr, [r5]         /* r5 still points to caml_young_ptr */
         ldr     alloc_limit, [r6]
     /* Return */
         bx      r4
+        .type   caml_c_call, %function
+        .size   caml_c_call, .-caml_c_call
 
 /* Start the OCaml program */
 
         .align  2
-        .globl  G(caml_start_program)
-        .thumb_func  G(caml_start_program)
-G(caml_start_program):
-        ldr     r12, LBL(caml_program)
+        .globl  caml_start_program
+        .type caml_start_program, %function
+caml_start_program:
+        PROFILE
+        ldr     r12, =caml_program
 
 /* Code shared with caml_callback* */
 /* Address of OCaml code to call is in r12 */
 /* Arguments to the OCaml code are in r0...r3 */
 
-LBL(jump_to_caml):
+.Ljump_to_caml:
     /* Save return address and callee-save registers */
         vpush   {d8-d15}
         push    {r4-r8,r10,r11,lr}              /* 8-byte alignment */
     /* Setup a callback link on the stack */
         sub     sp, sp, 4*4                     /* 8-byte alignment */
-        ldr     r4, LBL(caml_bottom_of_stack)
-        ldr     r5, LBL(caml_last_return_address)
-        ldr     r6, LBL(caml_gc_regs)
+        ldr     r4, =caml_bottom_of_stack
+        ldr     r5, =caml_last_return_address
+        ldr     r6, =caml_gc_regs
         ldr     r4, [r4]
         ldr     r5, [r5]
         ldr     r6, [r6]
@@ -240,65 +252,71 @@
         str     r6, [sp, 8]
     /* Setup a trap frame to catch exceptions escaping the OCaml code */
         sub     sp, sp, 2*4
-        ldr     r6, LBL(caml_exception_pointer)
-        ldr     r5, LBL(Ltrap_handler)
+        ldr     r6, =caml_exception_pointer
+        ldr     r5, =.Ltrap_handler
         ldr     r4, [r6]
         str     r4, [sp, 0]
         str     r5, [sp, 4]
         mov     trap_ptr, sp
     /* Reload allocation pointers */
-        ldr     r4, LBL(caml_young_ptr)
+        ldr     r4, =caml_young_ptr
         ldr     alloc_ptr, [r4]
-        ldr     r4, LBL(caml_young_limit)
+        ldr     r4, =caml_young_limit
         ldr     alloc_limit, [r4]
     /* Call the OCaml code */
         blx     r12
-LBL(caml_retaddr):
+.Lcaml_retaddr:
     /* Pop the trap frame, restoring caml_exception_pointer */
-        ldr     r4, LBL(caml_exception_pointer)
+        ldr     r4, =caml_exception_pointer
         ldr     r5, [sp, 0]
         str     r5, [r4]
         add     sp, sp, 2*4
     /* Pop the callback link, restoring the global variables */
-LBL(return_result):
-        ldr     r4, LBL(caml_bottom_of_stack)
+.Lreturn_result:
+        ldr     r4, =caml_bottom_of_stack
         ldr     r5, [sp, 0]
         str     r5, [r4]
-        ldr     r4, LBL(caml_last_return_address)
+        ldr     r4, =caml_last_return_address
         ldr     r5, [sp, 4]
         str     r5, [r4]
-        ldr     r4, LBL(caml_gc_regs)
+        ldr     r4, =caml_gc_regs
         ldr     r5, [sp, 8]
         str     r5, [r4]
         add     sp, sp, 4*4
     /* Update allocation pointer */
-        ldr     r4, LBL(caml_young_ptr)
+        ldr     r4, =caml_young_ptr
         str     alloc_ptr, [r4]
     /* Reload callee-save registers and return */
         pop     {r4-r8,r10,r11,lr}
         vpop    {d8-d15}
         bx      lr
+        .type   .Lcaml_retaddr, %function
+        .size   .Lcaml_retaddr, .-.Lcaml_retaddr
+        .type   caml_start_program, %function
+        .size   caml_start_program, .-caml_start_program
 
 /* The trap handler */
 
         .align  2
-LBL(trap_handler):
+.Ltrap_handler:
     /* Save exception pointer */
-        ldr     r12, LBL(caml_exception_pointer)
+        ldr     r12, =caml_exception_pointer
         str     trap_ptr, [r12]
     /* Encode exception bucket as an exception result */
         orr     r0, r0, 2
     /* Return it */
-        b       LBL(return_result)
+        b       .Lreturn_result
+        .type   .Ltrap_handler, %function
+        .size   .Ltrap_handler, .-.Ltrap_handler
 
 /* Raise an exception from OCaml */
 
         .align  2
-        .globl  G(caml_raise_exn)
-        .thumb_func  G(caml_raise_exn)
-G(caml_raise_exn):
+        .globl  caml_raise_exn
+caml_raise_exn:
+        PROFILE
     /* Test if backtrace is active */
-        ldr     r1, LBL(caml_backtrace_active)
+        ldr     r1, =caml_backtrace_active
         ldr     r1, [r1]
         cbz     r1, 1f
     /* Preserve exception bucket in callee-save register r4 */
@@ -307,75 +325,87 @@
         mov     r1, lr                          /* arg2: pc of raise */
         mov     r2, sp                          /* arg3: sp of raise */
         mov     r3, trap_ptr                    /* arg4: sp of handler */
-        bl      G(caml_stash_backtrace)
+        bl      caml_stash_backtrace
     /* Restore exception bucket */
         mov     r0, r4
 1:  /* Cut stack at current trap handler */
         mov     sp, trap_ptr
     /* Pop previous handler and addr of trap, and jump to it */
         pop     {trap_ptr, pc}
+        .type   caml_raise_exn, %function
+        .size   caml_raise_exn, .-caml_raise_exn
 
 /* Raise an exception from C */
 
         .align  2
-        .globl  G(caml_raise_exception)
-        .thumb_func  G(caml_raise_exception)
-G(caml_raise_exception):
+        .globl  caml_raise_exception
+        .type caml_raise_exception, %function
+caml_raise_exception:
+        PROFILE
     /* Reload trap ptr, alloc ptr and alloc limit */
-        ldr     trap_ptr, LBL(caml_exception_pointer)
-        ldr     alloc_ptr, LBL(caml_young_ptr)
-        ldr     alloc_limit, LBL(caml_young_limit)
+        ldr     trap_ptr, =caml_exception_pointer
+        ldr     alloc_ptr, =caml_young_ptr
+        ldr     alloc_limit, =caml_young_limit
         ldr     trap_ptr, [trap_ptr]
         ldr     alloc_ptr, [alloc_ptr]
         ldr     alloc_limit, [alloc_limit]
     /* Test if backtrace is active */
-        ldr     r1, LBL(caml_backtrace_active)
+        ldr     r1, =caml_backtrace_active
         ldr     r1, [r1]
         cbz     r1, 1f
     /* Preserve exception bucket in callee-save register r4 */
         mov     r4, r0
-        ldr     r1, LBL(caml_last_return_address)   /* arg2: pc of raise */
+        ldr     r1, =caml_last_return_address   /* arg2: pc of raise */
         ldr     r1, [r1]
-        ldr     r2, LBL(caml_bottom_of_stack)       /* arg3: sp of raise */
+        ldr     r2, =caml_bottom_of_stack       /* arg3: sp of raise */
         ldr     r2, [r2]
         mov     r3, trap_ptr                    /* arg4: sp of handler */
-        bl      G(caml_stash_backtrace)
+        bl      caml_stash_backtrace
     /* Restore exception bucket */
         mov     r0, r4
 1:  /* Cut stack at current trap handler */
         mov     sp, trap_ptr
     /* Pop previous handler and addr of trap, and jump to it */
         pop     {trap_ptr, pc}
+        .type   caml_raise_exception, %function
+        .size   caml_raise_exception, .-caml_raise_exception
 
 /* Callback from C to OCaml */
 
         .align  2
-        .globl  G(caml_callback_exn)
-        .thumb_func  G(caml_callback_exn)
-G(caml_callback_exn):
+        .globl  caml_callback_exn
+        .type caml_callback_exn, %function
+caml_callback_exn:
+        PROFILE
     /* Initial shuffling of arguments (r0 = closure, r1 = first arg) */
         mov     r12, r0
         mov     r0, r1          /* r0 = first arg */
         mov     r1, r12         /* r1 = closure environment */
         ldr     r12, [r12]      /* code pointer */
-        b       LBL(jump_to_caml)
+        b       .Ljump_to_caml
+        .type   caml_callback_exn, %function
+        .size   caml_callback_exn, .-caml_callback_exn
 
         .align  2
-        .globl  G(caml_callback2_exn)
-        .thumb_func  G(caml_callback2_exn)
-G(caml_callback2_exn):
+        .globl  caml_callback2_exn
+        .type caml_callback2_exn, %function
+caml_callback2_exn:
+        PROFILE
     /* Initial shuffling of arguments (r0 = closure, r1 = arg1, r2 = arg2) */
         mov     r12, r0
         mov     r0, r1          /* r0 = first arg */
         mov     r1, r2          /* r1 = second arg */
         mov     r2, r12         /* r2 = closure environment */
-        ldr     r12, LBL(caml_apply2)
-        b       LBL(jump_to_caml)
+        ldr     r12, =caml_apply2
+        b       .Ljump_to_caml
+        .type   caml_callback2_exn, %function
+        .size   caml_callback2_exn, .-caml_callback2_exn
 
         .align  2
-        .globl  G(caml_callback3_exn)
-        .thumb_func  G(caml_callback3_exn)
-G(caml_callback3_exn):
+        .globl  caml_callback3_exn
+        .type caml_callback3_exn, %function
+caml_callback3_exn:
+        PROFILE
     /* Initial shuffling of arguments */
     /* (r0 = closure, r1 = arg1, r2 = arg2, r3 = arg3) */
         mov     r12, r0
@@ -383,70 +413,36 @@
         mov     r1, r2          /* r1 = second arg */
         mov     r2, r3          /* r2 = third arg */
         mov     r3, r12         /* r3 = closure environment */
-        ldr     r12, LBL(caml_apply3)
-        b       LBL(jump_to_caml)
+        ldr     r12, =caml_apply3
+        b       .Ljump_to_caml
+        .type   caml_callback3_exn, %function
+        .size   caml_callback3_exn, .-caml_callback3_exn
 
         .align  2
-        .globl  G(caml_ml_array_bound_error)
-				.thumb_func G(caml_ml_array_bound_error)
-G(caml_ml_array_bound_error):
+        .globl  caml_ml_array_bound_error
+        .type caml_ml_array_bound_error, %function
+caml_ml_array_bound_error:
+        PROFILE
     /* Load address of [caml_array_bound_error] in r7 */
-        ldr     r7, LBL(caml_array_bound_error)
+        ldr     r7, =caml_array_bound_error
     /* Call that function */
-        b       G(caml_c_call)
+        b       caml_c_call
+        .type   caml_ml_array_bound_error, %function
+        .size   caml_ml_array_bound_error, .-caml_ml_array_bound_error
 
-        .globl  G(caml_system__code_end)
-G(caml_system__code_end):
+        .globl  caml_system__code_end
+caml_system__code_end:
 
-
-/*
-			.section  __DATA,__nl_symbol_ptr,non_lazy_symbol_pointers
-			.align 2
-	LBL(caml_last_return_address):
-			.indirect_symbol G(caml_last_return_address)
-			.long 0
- 	LBL(caml_backtrace_active):        
-			.indirect_symbol G(caml_backtrace_active)
-			.long 0
- 	LBL(caml_bottom_of_stack):         
-			.inderect_symbol G(caml_bottom_of_stack)
-			.long 0
-	LBL(caml_gc_regs):                 
-		.inderect_symbol G(caml_gc_regs)
-		.long 0
-	LBL(caml_young_ptr):               
-		.inderect_symbol G(caml_young_ptr)
-		.long 0
-	LBL(caml_young_limit):             
-		.inderect_symbol G(caml_young_limit)
-		.long 0
-	LBL(caml_exception_pointer):       
-		.inderect_symbol G(caml_exception_pointer) 
-		.long 0
-*/
-
-	LBL(caml_last_return_address): .word G(caml_last_return_address)
- 	LBL(caml_backtrace_active):	.word G(caml_backtrace_active)
- 	LBL(caml_bottom_of_stack): .word G(caml_bottom_of_stack)
-	LBL(caml_gc_regs): .word G(caml_gc_regs)
-	LBL(caml_young_ptr): .word G(caml_young_ptr)
-	LBL(caml_young_limit): .word G(caml_young_limit)
-	LBL(caml_exception_pointer): .word G(caml_exception_pointer)
-  LBL(caml_program):								.word G(caml_program)
-	LBL(Ltrap_handler):               .word LBL(trap_handler) 
-	LBL(caml_apply2):                 .word G(caml_apply2)
-	LBL(caml_apply3):                 .word G(caml_apply3)
-	LBL(caml_array_bound_error):      .word G(caml_array_bound_error)                
-        
 /* GC roots for callback */
 
         .data
         .align  2
-        .globl  G(caml_system__frametable)
-G(caml_system__frametable):
+        .globl  caml_system__frametable
+caml_system__frametable:
         .word   1               /* one descriptor */
-        .word   LBL(caml_retaddr)  /* return address into callback */
+        .word   .Lcaml_retaddr  /* return address into callback */
         .short  -1              /* negative frame size => use callback link */
         .short  0               /* no roots */
         .align  2
-
+        .type   caml_system__frametable, %object
+        .size   caml_system__frametable, .-caml_system__frametable
diff -urN ocaml-4.00-ios/asmrun/backtrace.c ocaml-4.00/asmrun/backtrace.c
--- ocaml-4.00-ios/asmrun/backtrace.c	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/asmrun/backtrace.c	2012-04-26 23:18:00.000000000 +0400
@@ -162,12 +162,12 @@
   li->loc_endchr = ((info2 & 0xF) << 6) | (info1 >> 26);
 }
 
-static char* print_location(struct loc_info * li, int index)
+static void print_location(struct loc_info * li, int index)
 {
   char * info;
 
   /* Ignore compiler-inserted raise */
-  if (!li->loc_valid) return NULL;
+  if (!li->loc_valid) return;
 
   if (index == 0)
     info = "Raised at";
@@ -175,12 +175,9 @@
     info = "Re-raised at";
   else
     info = "Called from";
-	char *res;
-	asprintf(&res,"%s file \"%s\", line %d, characters %d-%d\n",
+  fprintf (stderr, "%s file \"%s\", line %d, characters %d-%d\n",
            info, li->loc_filename, li->loc_lnum,
            li->loc_startchr, li->loc_endchr);
-  fputs (res,stderr);
-	return res;
 }
 
 /* Print a backtrace */
@@ -190,30 +187,12 @@
   int i;
   struct loc_info li;
 
-	char *msg;
   for (i = 0; i < caml_backtrace_pos; i++) {
     extract_location_info((frame_descr *) (caml_backtrace_buffer[i]), &li);
-		msg = print_location(&li, i);
-		if (msg) free(msg);
+    print_location(&li, i);
   }
 }
 
-char **caml_print_get_exception_backtrace(void)
-{
-	int i;
-  struct loc_info li;
-	char **res = NULL;
-
-	if (caml_backtrace_pos > 0) {
-		res = malloc(caml_backtrace_pos * sizeof(char*));
-		for (i = 0; i < caml_backtrace_pos; i++) {
-			extract_location_info((frame_descr *) (caml_backtrace_buffer[i]), &li);
-			res[i] = print_location(&li, i);
-		}
-	};
-	return res;
-}
-
 /* Convert the backtrace to a data structure usable from OCaml */
 
 CAMLprim value caml_get_exception_backtrace(value unit)
diff -urN ocaml-4.00-ios/byterun/Makefile.common ocaml-4.00/byterun/Makefile.common
--- ocaml-4.00-ios/byterun/Makefile.common	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/byterun/Makefile.common	2012-04-26 23:17:55.000000000 +0400
@@ -61,13 +61,6 @@
 	cp ld.conf $(LIBDIR)/ld.conf
 .PHONY: install
 
-installopt:
-	if test -d $(LIBDIR)/caml; then : ; else mkdir $(LIBDIR)/caml; fi
-	for i in $(PUBLIC_INCLUDES); do \
-		sed -f ../tools/cleanup-header $$i > $(LIBDIR)/caml/$$i; \
-  done
-.PHONY: installopt
-
 install:: install-$(RUNTIMED)
 
 install-noruntimed:
diff -urN ocaml-4.00-ios/byterun/backtrace.c ocaml-4.00/byterun/backtrace.c
--- ocaml-4.00-ios/byterun/backtrace.c	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/byterun/backtrace.c	2012-04-26 23:17:55.000000000 +0400
@@ -274,11 +274,6 @@
   }
 }
 
-CAMLexport char** caml_print_get_exception_backtrace(void) {
-	caml_print_exception_backtrace();
-	return NULL;
-}
-
 /* Convert the backtrace to a data structure usable from OCaml */
 
 CAMLprim value caml_get_exception_backtrace(value unit)
diff -urN ocaml-4.00-ios/byterun/backtrace.h ocaml-4.00/byterun/backtrace.h
--- ocaml-4.00-ios/byterun/backtrace.h	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/byterun/backtrace.h	2012-04-26 23:17:55.000000000 +0400
@@ -29,6 +29,5 @@
 extern void caml_stash_backtrace(value exn, code_t pc, value * sp);
 #endif
 CAMLextern void caml_print_exception_backtrace(void);
-CAMLextern char** caml_print_get_exception_backtrace(void);
 
 #endif /* CAML_BACKTRACE_H */
diff -urN ocaml-4.00-ios/byterun/fail.h ocaml-4.00/byterun/fail.h
--- ocaml-4.00-ios/byterun/fail.h	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/byterun/fail.h	2012-04-26 23:17:55.000000000 +0400
@@ -62,9 +62,6 @@
 extern "C" {
 #endif
 
-typedef void (*uncaught_exception_callback_t)(const char* exn,int bc,char** bv);
-extern uncaught_exception_callback_t uncaught_exception_callback;
-
 CAMLextern void caml_raise (value bucket) Noreturn;
 CAMLextern void caml_raise_constant (value tag) Noreturn;
 CAMLextern void caml_raise_with_arg (value tag, value arg) Noreturn;
diff -urN ocaml-4.00-ios/byterun/printexc.c ocaml-4.00/byterun/printexc.c
--- ocaml-4.00-ios/byterun/printexc.c	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/byterun/printexc.c	2012-04-26 23:17:55.000000000 +0400
@@ -26,8 +26,6 @@
 #include "mlvalues.h"
 #include "printexc.h"
 
-uncaught_exception_callback_t uncaught_exception_callback = NULL;
-
 struct stringbuf {
   char * ptr;
   char * end;
@@ -115,22 +113,15 @@
   caml_backtrace_pos = saved_backtrace_pos;
   /* Display the uncaught exception */
   fprintf(stderr, "Fatal error: exception %s\n", msg);
+  free(msg);
   /* Display the backtrace if available */
-	char **backtraces = NULL;
   if (caml_backtrace_active
 #ifndef NATIVE_CODE
       && !caml_debugger_in_use
 #endif
       ) {
-    backtraces = caml_print_get_exception_backtrace();
+    caml_print_exception_backtrace();
   }
   /* Terminate the process */
-	if (uncaught_exception_callback != NULL) uncaught_exception_callback(msg,caml_backtrace_active ? caml_backtrace_pos : 0,backtraces);
-  free(msg);
-	if (backtraces != NULL) {
-		int i;
-		for (i = 0; i < caml_backtrace_pos; i++) if (backtraces[i]) free(backtraces[i]);
-		free(backtraces);
-	};
   exit(2);
 }
diff -urN ocaml-4.00-ios/config/Makefile ocaml-4.00/config/Makefile
--- ocaml-4.00-ios/config/Makefile	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/config/Makefile	1970-01-01 03:00:00.000000000 +0300
@@ -1,73 +0,0 @@
-PREFIX=/usr/local/ocaml/ios/4.00
-PLATFORM=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer
-SDK=$(PLATFORM)/SDKs/iPhoneOS5.1.sdk
-BINDIR=$(PREFIX)/bin
-LIBDIR=$(PREFIX)/lib
-STUBLIBDIR=$(LIBDIR)/stublibs
-MANDIR=$(PREFIX)/man
-MANEXT=1
-RANLIB=$(PLATFORM)/usr/bin/ranlib
-RANLIBCMD=$(RANLIB)
-ARCMD=$(PLATFORM)/usr/bin/ar
-SHARPBANGSCRIPTS=true
-BNG_ARCH=generic
-BNG_ASM_LEVEL=0
-PTHREAD_LINK=-cclib -pthread
-LIBBFD_LINK=-lbfd -ldl -liberty -lz
-BYTECC=$(PLATFORM)/usr/bin/gcc -arch armv7 -isysroot $(SDK)
-#BYTECCCOMPOPTS=-fno-defer-pop -Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__
-BYTECCCOMPOPTS=-fno-defer-pop -no-cpp-precomp -Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__
-BYTECCLINKOPTS= -Wl
-BYTECCLIBS= -lpthread
-BYTECCRPATH=-Wl,-rpath,
-EXE=
-SUPPORTS_SHARED_LIBRARIES=false
-#SHAREDCCCOMPOPTS=-fPIC
-MKSHAREDLIBRPATH=-Wl,-rpath,
-NATDYNLINKOPTS=-Wl
-SYSLIB=-l$(1)
-#ml let syslib x = "-l"^x;;
-
-### How to build a static library
-MKLIB=$(ARCMD) rc $(1) $(2); $(RANLIB) $(1)
-#ml let mklib out files opts = Printf.sprintf "ar rc %s %s %s; ranlib %s" out opts files out;;
-ARCH=arm
-MODEL=armv7
-SYSTEM=linux_eabihf
-NATIVECC=$(BYTECC)
-NATIVECCCOMPOPTS=-Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__ -miphoneos-version-min=4.3
-# -gdwarf-2 -fexceptions
-NATIVECCPROFOPTS=-Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__
-NATIVECCLINKOPTS=
-NATIVECCRPATH=-Wl,-rpath,
-NATIVECCLIBS= -lm  -ldl
-ASM=$(NATIVECC) -D__ARM_EABI__ -c 
-ASPP=$(ASM)
-ASPPPROFFLAGS=-DPROFILING
-PROFILING=noprof
-DYNLINKOPTS= -ldl
-OTHERLIBRARIES=unix str num dynlink bigarray threads systhreads
-DEBUGGER=ocamldebugger
-CC_PROFILE=-pg
-SYSTHREAD_SUPPORT=false
-PARTIALLD=ld -r
-PACKLD=$(PARTIALLD) $(NATIVECCLINKOPTS) -o\ 
-DLLCCCOMPOPTS=
-IFLEXDIR=
-O=o
-A=a
-SO=so
-EXT_OBJ=.o
-EXT_ASM=.s
-EXT_LIB=.a
-EXT_DLL=.so
-EXTRALIBS=
-CCOMPTYPE=cc
-TOOLCHAIN=cc
-NATDYNLINK=false
-CMXS=cmxa
-MKEXE=$(BYTECC)
-MKDLL=$(NATIVECC) -bundle -flat_namespace -undefined suppress
-MKMAINDLL=$(MKDLL)
-RUNTIMED=noruntimed
-ASM_CFI_SUPPORTED=false
diff -urN ocaml-4.00-ios/config/m.h ocaml-4.00/config/m.h
--- ocaml-4.00-ios/config/m.h	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/config/m.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,16 +0,0 @@
-#ifndef __PIC__
-#  define ARCH_CODE32
-#endif
-#undef ARCH_SIXTYFOUR
-#define SIZEOF_INT 4
-#define SIZEOF_LONG 4
-#define SIZEOF_PTR 4
-#define SIZEOF_SHORT 2
-#define ARCH_INT64_TYPE long long
-#define ARCH_UINT64_TYPE unsigned long long
-#define ARCH_INT64_PRINTF_FORMAT "ll"
-#undef ARCH_BIG_ENDIAN
-#undef ARCH_ALIGN_DOUBLE
-#undef ARCH_ALIGN_INT64
-#undef NONSTANDARD_DIV_MOD
-#define ASM_CFI_SUPPORTED
diff -urN ocaml-4.00-ios/config/s.h ocaml-4.00/config/s.h
--- ocaml-4.00-ios/config/s.h	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/config/s.h	1970-01-01 03:00:00.000000000 +0300
@@ -1,51 +0,0 @@
-#define OCAML_OS_TYPE "Unix"
-#define OCAML_STDLIB_DIR "/usr/local/ocaml/ios/4.00/lib"
-#define POSIX_SIGNALS
-#define HAS_C99_FLOAT_OPS
-#define HAS_GETRUSAGE
-#define HAS_TIMES
-#undef HAS_TERMCAP
-#define HAS_SOCKETS
-#define HAS_SOCKLEN_T
-#define HAS_INET_ATON
-#define HAS_IPV6
-#define HAS_UNISTD
-#define HAS_OFF_T
-#define HAS_DIRENT
-#define HAS_REWINDDIR
-#define HAS_LOCKF
-#define HAS_MKFIFO
-#define HAS_GETCWD
-#define HAS_GETWD
-#define HAS_GETPRIORITY
-#define HAS_UTIME
-#define HAS_UTIMES
-#define HAS_DUP2
-#define HAS_FCHMOD
-#define HAS_TRUNCATE
-#define HAS_SYS_SELECT_H
-#define HAS_SELECT
-#define HAS_SYMLINK
-#define HAS_WAITPID
-#define HAS_WAIT4
-#define HAS_GETGROUPS
-#define HAS_SETGROUPS
-#define HAS_INITGROUPS
-#define HAS_TERMIOS
-#define HAS_ASYNC_IO
-#define HAS_SETITIMER
-#define HAS_GETHOSTNAME
-#define HAS_UNAME
-#define HAS_GETTIMEOFDAY
-#define HAS_MKTIME
-#define HAS_SETSID
-#define HAS_PUTENV
-#define HAS_LOCALE
-#undef SUPPORT_DYNAMIC_LINKING
-#define HAS_MMAP
-#define HAS_PWRITE
-#undef HAS_GETHOSTBYNAME_R
-#undef HAS_GETHOSTBYADDR_R
-#undef HAS_STACK_OVERFLOW_DETECTION
-#define HAS_SIGWAIT
-#undef HAS_LIBBFD
diff -urN ocaml-4.00-ios/otherlibs/Makefile.shared ocaml-4.00/otherlibs/Makefile.shared
--- ocaml-4.00-ios/otherlibs/Makefile.shared	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/otherlibs/Makefile.shared	2012-04-26 23:17:59.000000000 +0400
@@ -20,7 +20,7 @@
 
 # Compilation options
 CC=$(BYTECC)
-CAMLRUN=ocamlrun
+CAMLRUN=$(ROOTDIR)/boot/ocamlrun
 COMPFLAGS=-warn-error A -g $(EXTRACAMLFLAGS)
 MKLIB=$(CAMLRUN) $(ROOTDIR)/tools/ocamlmklib
 
@@ -65,13 +65,9 @@
 	if test -n "$(HEADERS)"; then cp $(HEADERS) $(LIBDIR)/caml/; fi
 
 installopt:
-	cp lib$(CLIBNAME).$(A) $(LIBDIR)/
-	cd $(LIBDIR); $(RANLIB) lib$(CLIBNAME).$(A)
 	cp $(CAMLOBJS_NAT) $(LIBNAME).cmxa $(LIBNAME).$(A) $(LIBDIR)/
 	cd $(LIBDIR); $(RANLIB) $(LIBNAME).a
-	cp $(CMIFILES) $(CMIFILES:.cmi=.mli) $(LIBDIR)/
 	if test -f $(LIBNAME).cmxs; then cp $(LIBNAME).cmxs $(LIBDIR)/; fi
-	if test -n "$(HEADERS)"; then cp $(HEADERS) $(LIBDIR)/caml/; fi
 
 partialclean:
 	rm -f *.cm*
diff -urN ocaml-4.00-ios/otherlibs/dynlink/Makefile ocaml-4.00/otherlibs/dynlink/Makefile
--- ocaml-4.00-ios/otherlibs/dynlink/Makefile	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/otherlibs/dynlink/Makefile	2012-05-31 14:32:03.000000000 +0400
@@ -17,7 +17,7 @@
 
 include ../../config/Makefile
 
-CAMLC=../../ocamlcomp.sh
+CAMLC=../../boot/ocamlrun ../../ocamlc
 CAMLOPT=../../ocamlcompopt.sh
 INCLUDES=-I ../../utils -I ../../typing -I ../../bytecomp -I ../../asmcomp
 COMPFLAGS=-warn-error A -I ../../stdlib $(INCLUDES)
diff -urN ocaml-4.00-ios/otherlibs/systhreads/Makefile ocaml-4.00/otherlibs/systhreads/Makefile
--- ocaml-4.00-ios/otherlibs/systhreads/Makefile	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/otherlibs/systhreads/Makefile	2012-06-15 18:39:15.000000000 +0400
@@ -17,7 +17,7 @@
 
 CAMLC=../../ocamlcomp.sh -I ../unix
 CAMLOPT=../../ocamlcompopt.sh -I ../unix
-MKLIB=../../tools/ocamlmklib
+MKLIB=../../boot/ocamlrun ../../tools/ocamlmklib
 COMPFLAGS=-warn-error A -g
 
 BYTECODE_C_OBJS=st_stubs_b.o
@@ -61,6 +61,7 @@
 # modular to me this way. -- Alain
 
 
+$(THREAD_OBJS:.cmo=.cmx): ../../ocamlopt
 
 partialclean:
 	rm -f *.cm*
@@ -79,10 +80,6 @@
 	cp threads.h $(LIBDIR)/caml/threads.h
 
 installopt:
-	if test -d $(LIBDIR)/threads; then :; else mkdir $(LIBDIR)/threads; fi
-	cp $(THREAD_OBJS:.cmo=.cmi) $(LIBDIR)/threads
-	cp thread.mli mutex.mli condition.mli event.mli threadUnix.mli $(LIBDIR)
-	cp threads.h $(LIBDIR)/caml/threads.h
 	cp libthreadsnat.a $(LIBDIR)/libthreadsnat.a
 	cd $(LIBDIR); $(RANLIB) libthreadsnat.a
 	cp $(THREAD_OBJS:.cmo=.cmx) threads.cmxa threads.a $(LIBDIR)/threads
diff -urN ocaml-4.00-ios/otherlibs/threads/pervasives.ml ocaml-4.00/otherlibs/threads/pervasives.ml
--- ocaml-4.00-ios/otherlibs/threads/pervasives.ml	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/otherlibs/threads/pervasives.ml	2012-04-26 23:17:59.000000000 +0400
@@ -87,29 +87,29 @@
 external (-.) : float -> float -> float = "%subfloat"
 external ( *. ) : float -> float -> float = "%mulfloat"
 external (/.) : float -> float -> float = "%divfloat"
-external ( ** ) : float -> float -> float = "caml_power_float" (* "pow" "float" *)
-external exp : float -> float = "caml_exp_float" (* "exp" "float" *)
-external expm1 : float -> float = "caml_expm1_float" (* "caml_expm1" "float" *)
-external acos : float -> float = "caml_acos_float" (* "acos" "float" *)
-external asin : float -> float = "caml_asin_float" (* "asin" "float" *)
-external atan : float -> float = "caml_atan_float" (* "atan" "float" *)
-external atan2 : float -> float -> float = "caml_atan2_float" (* "atan2" "float" *)
-external hypot : float -> float -> float = "caml_hypot_float" (* "caml_hypot" "float" *)
-external cos : float -> float = "caml_cos_float" (* "cos" "float" *)
-external cosh : float -> float = "caml_cosh_float" (* "cosh" "float" *)
-external log : float -> float = "caml_log_float" (* "log" "float" *)
-external log10 : float -> float = "caml_log10_float" (* "log10" "float" *)
-external log1p : float -> float = "caml_log1p_float" (* "caml_log1p" "float" *)
-external sin : float -> float = "caml_sin_float" (* "sin" "float" *)
-external sinh : float -> float = "caml_sinh_float" (* "sinh" "float" *)
-external sqrt : float -> float = "caml_sqrt_float" (* "sqrt" "float" *)
-external tan : float -> float = "caml_tan_float" (* "tan" "float" *)
-external tanh : float -> float = "caml_tanh_float" (* "tanh" "float" *)
-external ceil : float -> float = "caml_ceil_float" (* "ceil" "float" *)
-external floor : float -> float = "caml_floor_float" (* "floor" "float" *)
+external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
+external exp : float -> float = "caml_exp_float" "exp" "float"
+external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
+external acos : float -> float = "caml_acos_float" "acos" "float"
+external asin : float -> float = "caml_asin_float" "asin" "float"
+external atan : float -> float = "caml_atan_float" "atan" "float"
+external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
+external hypot : float -> float -> float = "caml_hypot_float" "caml_hypot" "float"
+external cos : float -> float = "caml_cos_float" "cos" "float"
+external cosh : float -> float = "caml_cosh_float" "cosh" "float"
+external log : float -> float = "caml_log_float" "log" "float"
+external log10 : float -> float = "caml_log10_float" "log10" "float"
+external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
+external sin : float -> float = "caml_sin_float" "sin" "float"
+external sinh : float -> float = "caml_sinh_float" "sinh" "float"
+external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
+external tan : float -> float = "caml_tan_float" "tan" "float"
+external tanh : float -> float = "caml_tanh_float" "tanh" "float"
+external ceil : float -> float = "caml_ceil_float" "ceil" "float"
+external floor : float -> float = "caml_floor_float" "floor" "float"
 external abs_float : float -> float = "%absfloat"
-external copysign : float -> float -> float = "caml_copysign_float" (* "caml_copysign" "float" *)
-external mod_float : float -> float -> float = "caml_fmod_float" (* "fmod" "float" *)
+external copysign : float -> float -> float = "caml_copysign_float" "caml_copysign" "float"
+external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
 external frexp : float -> float * int = "caml_frexp_float"
 external ldexp : float -> int -> float = "caml_ldexp_float"
 external modf : float -> float * float = "caml_modf_float"
diff -urN ocaml-4.00-ios/stdlib/Makefile ocaml-4.00/stdlib/Makefile
--- ocaml-4.00-ios/stdlib/Makefile	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/stdlib/Makefile	2012-04-26 23:17:52.000000000 +0400
@@ -15,7 +15,7 @@
 
 include Makefile.shared
 
-allopt: stdlib.cmxa std_exit.cmx camlheader camlheader_ur allopt-$(PROFILING)
+allopt: stdlib.cmxa std_exit.cmx allopt-$(PROFILING)
 
 allopt-noprof:
 
@@ -25,7 +25,7 @@
 installopt: installopt-default installopt-$(PROFILING)
 
 installopt-default:
-	cp stdlib.cmxa stdlib.a std_exit.o *.cmx *.cmi *.mli *.ml camlheader camlheader_ur $(LIBDIR)
+	cp stdlib.cmxa stdlib.a std_exit.o *.cmx $(LIBDIR)
 	cd $(LIBDIR); $(RANLIB) stdlib.a
 
 installopt-noprof:
diff -urN ocaml-4.00-ios/stdlib/Makefile.shared ocaml-4.00/stdlib/Makefile.shared
--- ocaml-4.00-ios/stdlib/Makefile.shared	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/stdlib/Makefile.shared	2012-04-26 23:17:52.000000000 +0400
@@ -14,12 +14,14 @@
 # $Id: Makefile.shared 12383 2012-04-19 13:12:23Z xleroy $
 
 include ../config/Makefile
-RUNTIME=ocamlrun
-CAMLC=ocamlc.opt
+RUNTIME=../boot/ocamlrun
+COMPILER=../ocamlc
+CAMLC=$(RUNTIME) $(COMPILER)
 COMPFLAGS=-strict-sequence -g -warn-error A -nostdlib
-CAMLOPT=../ocamlopt.opt
+OPTCOMPILER=../ocamlopt
+CAMLOPT=$(RUNTIME) $(OPTCOMPILER)
 OPTCOMPFLAGS=-warn-error A -nostdlib -g
-CAMLDEP=ocamldep.opt
+CAMLDEP=../boot/ocamlrun ../tools/ocamldep
 
 OBJS=pervasives.cmo $(OTHERS)
 OTHERS=array.cmo list.cmo char.cmo string.cmo sys.cmo \
@@ -78,6 +80,11 @@
 .ml.p.cmx:
 	$(CAMLOPT) $(OPTCOMPFLAGS) `./Compflags $@` -p -c -o $*.p.cmx $<
 
+# Dependencies on the compiler
+$(OBJS) std_exit.cmo: $(COMPILER)
+$(OBJS:.cmo=.cmi) std_exit.cmi: $(COMPILER)
+$(OBJS:.cmo=.cmx) std_exit.cmx: $(OPTCOMPILER)
+$(OBJS:.cmo=.p.cmx) std_exit.p.cmx: $(OPTCOMPILER)
 
 # Dependencies on Pervasives (not tracked by ocamldep)
 $(OBJS) std_exit.cmo: pervasives.cmi
diff -urN ocaml-4.00-ios/stdlib/camlinternalOO.ml ocaml-4.00/stdlib/camlinternalOO.ml
--- ocaml-4.00-ios/stdlib/camlinternalOO.ml	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/stdlib/camlinternalOO.ml	2012-04-26 23:17:52.000000000 +0400
@@ -78,9 +78,9 @@
     accu := 223 * !accu + Char.code s.[i]
   done;
   (* reduce to 31 bits *)
-  let tag = !accu land (1 lsl 31 - 1) in
+  accu := !accu land (1 lsl 31 - 1);
   (* make it signed for 64 bits architectures *)
-(*   let tag = if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu in *)
+  let tag = if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu in
   (* Printf.eprintf "%s = %d\n" s tag; flush stderr; *)
   magic tag
 
diff -urN ocaml-4.00-ios/stdlib/pervasives.ml ocaml-4.00/stdlib/pervasives.ml
--- ocaml-4.00-ios/stdlib/pervasives.ml	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/stdlib/pervasives.ml	2012-04-26 23:17:52.000000000 +0400
@@ -72,7 +72,7 @@
 external ( lsr ) : int -> int -> int = "%lsrint"
 external ( asr ) : int -> int -> int = "%asrint"
 
-let min_int = 1 lsl 30
+let min_int = 1 lsl (if 1 lsl 31 = 0 then 30 else 62)
 let max_int = min_int - 1
 
 (* Floating-point operations *)
@@ -83,29 +83,31 @@
 external ( -. ) : float -> float -> float = "%subfloat"
 external ( *. ) : float -> float -> float = "%mulfloat"
 external ( /. ) : float -> float -> float = "%divfloat"
-external ( ** ) : float -> float -> float = "caml_power_float" (* "pow" "float" *)
-external exp : float -> float = "caml_exp_float" (* "exp" "float" *)
-external expm1 : float -> float = "caml_expm1_float" (* "caml_expm1" "float" *)
-external acos : float -> float = "caml_acos_float" (* "acos" "float" *)
-external asin : float -> float = "caml_asin_float" (* "asin" "float" *)
-external atan : float -> float = "caml_atan_float" (* "atan" "float" *)
-external atan2 : float -> float -> float = "caml_atan2_float" (* "atan2" "float" *)
-external hypot : float -> float -> float = "caml_hypot_float" (* "caml_hypot" "float" *)
-external cos : float -> float = "caml_cos_float" (* "cos" "float" *)
-external cosh : float -> float = "caml_cosh_float" (* "cosh" "float" *)
-external log : float -> float = "caml_log_float" (* "log" "float" *)
-external log10 : float -> float = "caml_log10_float" (* "log10" "float" *)
-external log1p : float -> float = "caml_log1p_float" (* "caml_log1p" "float" *)
-external sin : float -> float = "caml_sin_float" (* "sin" "float" *)
-external sinh : float -> float = "caml_sinh_float" (* "sinh" "float" *)
-external sqrt : float -> float = "caml_sqrt_float" (* "sqrt" "float" *)
-external tan : float -> float = "caml_tan_float" (* "tan" "float" *)
-external tanh : float -> float = "caml_tanh_float" (* "tanh" "float" *)
-external ceil : float -> float = "caml_ceil_float" (* "ceil" "float" *)
-external floor : float -> float = "caml_floor_float" (* "floor" "float" *)
+external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
+external exp : float -> float = "caml_exp_float" "exp" "float"
+external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
+external acos : float -> float = "caml_acos_float" "acos" "float"
+external asin : float -> float = "caml_asin_float" "asin" "float"
+external atan : float -> float = "caml_atan_float" "atan" "float"
+external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
+external hypot : float -> float -> float
+               = "caml_hypot_float" "caml_hypot" "float"
+external cos : float -> float = "caml_cos_float" "cos" "float"
+external cosh : float -> float = "caml_cosh_float" "cosh" "float"
+external log : float -> float = "caml_log_float" "log" "float"
+external log10 : float -> float = "caml_log10_float" "log10" "float"
+external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
+external sin : float -> float = "caml_sin_float" "sin" "float"
+external sinh : float -> float = "caml_sinh_float" "sinh" "float"
+external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
+external tan : float -> float = "caml_tan_float" "tan" "float"
+external tanh : float -> float = "caml_tanh_float" "tanh" "float"
+external ceil : float -> float = "caml_ceil_float" "ceil" "float"
+external floor : float -> float = "caml_floor_float" "floor" "float"
 external abs_float : float -> float = "%absfloat"
-external copysign : float -> float -> float = "caml_copysign_float" (* "caml_copysign" "float" *)
-external mod_float : float -> float -> float = "caml_fmod_float" (* "fmod" "float" *)
+external copysign : float -> float -> float
+                  = "caml_copysign_float" "caml_copysign" "float"
+external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
 external frexp : float -> float * int = "caml_frexp_float"
 external ldexp : float -> int -> float = "caml_ldexp_float"
 external modf : float -> float * float = "caml_modf_float"
diff -urN ocaml-4.00-ios/stdlib/pervasives.mli ocaml-4.00/stdlib/pervasives.mli
--- ocaml-4.00-ios/stdlib/pervasives.mli	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/stdlib/pervasives.mli	2012-05-05 17:00:39.000000000 +0400
@@ -261,81 +261,82 @@
 external ( /. ) : float -> float -> float = "%divfloat"
 (** Floating-point division. *)
 
-external ( ** ) : float -> float -> float = "caml_power_float" (* "pow" "float" *)
+external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
 (** Exponentiation. *)
 
-external sqrt : float -> float = "caml_sqrt_float" (* "sqrt" "float" *)
+external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
 (** Square root. *)
 
-external exp : float -> float = "caml_exp_float" (* "exp" "float" *)
+external exp : float -> float = "caml_exp_float" "exp" "float"
 (** Exponential. *)
 
-external log : float -> float = "caml_log_float" (* "log" "float" *)
+external log : float -> float = "caml_log_float" "log" "float"
 (** Natural logarithm. *)
 
-external log10 : float -> float = "caml_log10_float" (* "log10" "float" *)
+external log10 : float -> float = "caml_log10_float" "log10" "float"
 (** Base 10 logarithm. *)
 
-external expm1 : float -> float = "caml_expm1_float" (* "caml_expm1" "float" *)
+external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
 (** [expm1 x] computes [exp x -. 1.0], giving numerically-accurate results
     even if [x] is close to [0.0].
     @since 3.12.0
 *)
 
-external log1p : float -> float = "caml_log1p_float" (* "caml_log1p" "float" *)
+external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
 (** [log1p x] computes [log(1.0 +. x)] (natural logarithm),
     giving numerically-accurate results even if [x] is close to [0.0].
     @since 3.12.0
 *)
 
-external cos : float -> float = "caml_cos_float" (* "cos" "float" *)
+external cos : float -> float = "caml_cos_float" "cos" "float"
 (** Cosine.  Argument is in radians. *)
 
-external sin : float -> float = "caml_sin_float" (* "sin" "float" *)
+external sin : float -> float = "caml_sin_float" "sin" "float"
 (** Sine.  Argument is in radians. *)
 
-external tan : float -> float = "caml_tan_float" (* "tan" "float" *)
+external tan : float -> float = "caml_tan_float" "tan" "float"
 (** Tangent.  Argument is in radians. *)
 
-external acos : float -> float = "caml_acos_float" (* "acos" "float" *)
+external acos : float -> float = "caml_acos_float" "acos" "float"
 (** Arc cosine.  The argument must fall within the range [[-1.0, 1.0]].
     Result is in radians and is between [0.0] and [pi]. *)
 
-external asin : float -> float = "caml_asin_float" (* "asin" "float" *)
+external asin : float -> float = "caml_asin_float" "asin" "float"
 (** Arc sine.  The argument must fall within the range [[-1.0, 1.0]].
     Result is in radians and is between [-pi/2] and [pi/2]. *)
 
-external atan : float -> float = "caml_atan_float" (* "atan" "float" *)
+external atan : float -> float = "caml_atan_float" "atan" "float"
 (** Arc tangent.
     Result is in radians and is between [-pi/2] and [pi/2]. *)
 
-external atan2 : float -> float -> float = "caml_atan2_float" (* "atan2" "float" *) 
+external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
 (** [atan2 y x] returns the arc tangent of [y /. x].  The signs of [x]
     and [y] are used to determine the quadrant of the result.
     Result is in radians and is between [-pi] and [pi]. *)
 
-external hypot : float -> float -> float = "caml_hypot_float" (* "caml_hypot" "float" *)
+external hypot : float -> float -> float
+               = "caml_hypot_float" "caml_hypot" "float"
 (** [hypot x y] returns [sqrt(x *. x + y *. y)], that is, the length
   of the hypotenuse of a right-angled triangle with sides of length
   [x] and [y], or, equivalently, the distance of the point [(x,y)]
   to origin.
   @since 4.00.0  *)
 
-external cosh : float -> float = "caml_cosh_float" (* "cosh" "float" *)
+external cosh : float -> float = "caml_cosh_float" "cosh" "float"
 (** Hyperbolic cosine.  Argument is in radians. *)
 
-external sinh : float -> float = "caml_sinh_float" (* "sinh" "float" *)
+external sinh : float -> float = "caml_sinh_float" "sinh" "float"
 (** Hyperbolic sine.  Argument is in radians. *)
 
-external tanh : float -> float = "caml_tanh_float" (* "tanh" "float" *)
+external tanh : float -> float = "caml_tanh_float" "tanh" "float"
 (** Hyperbolic tangent.  Argument is in radians. *)
 
-external ceil : float -> float = "caml_ceil_float" (* "ceil" "float" *)
+external ceil : float -> float = "caml_ceil_float" "ceil" "float"
 (** Round above to an integer value.
     [ceil f] returns the least integer value greater than or equal to [f].
     The result is returned as a float. *)
 
-external floor : float -> float = "caml_floor_float" (* "floor" "float" *)
+external floor : float -> float = "caml_floor_float" "floor" "float"
 (** Round below to an integer value.
     [floor f] returns the greatest integer value less than or
     equal to [f].
@@ -345,15 +346,14 @@
 (** [abs_float f] returns the absolute value of [f]. *)
 
 external copysign : float -> float -> float
-                  = "caml_copysign_float" (* "caml_copysign" "float" *)
+                  = "caml_copysign_float" "caml_copysign" "float"
 (** [copysign x y] returns a float whose absolute value is that of [x]
   and whose sign is that of [y].  If [x] is [nan], returns [nan].
   If [y] is [nan], returns either [x] or [-. x], but it is not
   specified which.
   @since 4.00.0  *)
 
-external mod_float : float -> float -> float = "caml_fmod_float" (* "fmod"
-"float" *)
+external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
 (** [mod_float a b] returns the remainder of [a] with respect to
    [b].  The returned value is [a -. n *. b], where [n]
    is the quotient [a /. b] rounded towards zero to an integer. *)
diff -urN ocaml-4.00-ios/tools/Makefile.shared ocaml-4.00/tools/Makefile.shared
--- ocaml-4.00-ios/tools/Makefile.shared	2012-07-24 09:53:45.000000000 +0400
+++ ocaml-4.00/tools/Makefile.shared	2012-06-06 01:55:42.000000000 +0400
@@ -14,10 +14,10 @@
 
 include ../config/Makefile
 
-CAMLRUN=ocamlrun
-CAMLC=ocamlc.opt -strict-sequence -I ../boot
-CAMLOPT=ocamlopt.opt
-CAMLLEX=ocamllex
+CAMLRUN=../boot/ocamlrun
+CAMLC=$(CAMLRUN) ../boot/ocamlc -strict-sequence -nostdlib -I ../boot
+CAMLOPT=$(CAMLRUN) ../ocamlopt -nostdlib -I ../stdlib
+CAMLLEX=$(CAMLRUN) ../boot/ocamllex
 INCLUDES=-I ../utils -I ../parsing -I ../typing -I ../bytecomp -I ../asmcomp \
 	 -I ../driver
 COMPFLAGS= -warn-error A $(INCLUDES)
