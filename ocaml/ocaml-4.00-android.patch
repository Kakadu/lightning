diff -urN ocaml-4.00/Makefile.android ocaml-4.00-android/Makefile.android
--- ocaml-4.00/Makefile.android	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.00-android/Makefile.android	2012-05-11 16:15:48.000000000 +0400
@@ -0,0 +1,354 @@
+include config/Makefile
+include stdlib/StdlibModules
+
+CAMLC=ocamlc.opt
+CAMLOPT=ocamlopt.opt
+COMPFLAGS=-strict-sequence -warn-error A $(INCLUDES)
+LINKFLAGS=
+
+CAMLYACC=ocamlyacc
+YACCFLAGS=-v
+CAMLLEX=ocamllex.opt
+CAMLDEP=ocamldep.opt
+DEPFLAGS=$(INCLUDES)
+CAMLRUN=ocamlrun
+SHELL=/bin/sh
+MKDIR=mkdir -p
+
+INCLUDES=-I utils -I parsing -I typing -I bytecomp -I asmcomp -I driver \
+	 -I toplevel
+
+UTILS=utils/misc.cmo utils/tbl.cmo utils/config.cmo \
+  utils/clflags.cmo utils/terminfo.cmo utils/ccomp.cmo utils/warnings.cmo \
+  utils/consistbl.cmo
+
+OPTUTILS=$(UTILS)
+
+PARSING=parsing/location.cmo parsing/longident.cmo \
+  parsing/syntaxerr.cmo parsing/parser.cmo \
+  parsing/lexer.cmo parsing/parse.cmo parsing/printast.cmo
+
+TYPING=typing/ident.cmo typing/path.cmo \
+  typing/primitive.cmo typing/types.cmo \
+  typing/btype.cmo typing/oprint.cmo \
+  typing/subst.cmo typing/predef.cmo \
+  typing/datarepr.cmo typing/env.cmo \
+  typing/typedtree.cmo typing/ctype.cmo \
+  typing/printtyp.cmo typing/includeclass.cmo \
+  typing/mtype.cmo typing/includecore.cmo \
+  typing/includemod.cmo typing/parmatch.cmo \
+  typing/typetexp.cmo typing/stypes.cmo typing/typecore.cmo \
+  typing/typedecl.cmo typing/typeclass.cmo \
+  typing/typemod.cmo
+
+COMP=bytecomp/lambda.cmo bytecomp/printlambda.cmo \
+  bytecomp/typeopt.cmo bytecomp/switch.cmo bytecomp/matching.cmo \
+  bytecomp/translobj.cmo bytecomp/translcore.cmo \
+  bytecomp/translclass.cmo bytecomp/translmod.cmo \
+  bytecomp/simplif.cmo bytecomp/runtimedef.cmo
+
+BYTECOMP=bytecomp/meta.cmo bytecomp/instruct.cmo bytecomp/bytegen.cmo \
+  bytecomp/printinstr.cmo bytecomp/opcodes.cmo bytecomp/emitcode.cmo \
+  bytecomp/bytesections.cmo bytecomp/dll.cmo bytecomp/symtable.cmo \
+  bytecomp/bytelink.cmo bytecomp/bytelibrarian.cmo bytecomp/bytepackager.cmo
+
+ASMCOMP=asmcomp/arch.cmo asmcomp/debuginfo.cmo \
+  asmcomp/cmm.cmo asmcomp/printcmm.cmo \
+  asmcomp/reg.cmo asmcomp/mach.cmo asmcomp/proc.cmo \
+  asmcomp/clambda.cmo asmcomp/compilenv.cmo \
+  asmcomp/closure.cmo asmcomp/cmmgen.cmo \
+  asmcomp/printmach.cmo asmcomp/selectgen.cmo asmcomp/selection.cmo \
+  asmcomp/comballoc.cmo asmcomp/liveness.cmo \
+  asmcomp/spill.cmo asmcomp/split.cmo \
+  asmcomp/interf.cmo asmcomp/coloring.cmo \
+  asmcomp/reloadgen.cmo asmcomp/reload.cmo \
+  asmcomp/printlinear.cmo asmcomp/linearize.cmo \
+  asmcomp/schedgen.cmo asmcomp/scheduling.cmo \
+  asmcomp/emitaux.cmo asmcomp/emit.cmo asmcomp/asmgen.cmo \
+  asmcomp/asmlink.cmo asmcomp/asmlibrarian.cmo asmcomp/asmpackager.cmo
+
+DRIVER=driver/pparse.cmo driver/errors.cmo driver/compile.cmo \
+  driver/main_args.cmo driver/main.cmo
+
+OPTDRIVER= driver/pparse.cmo driver/opterrors.cmo driver/optcompile.cmo \
+  driver/main_args.cmo driver/optmain.cmo
+
+PERVASIVES=$(STDLIB_MODULES) outcometree topdirs toploop
+
+OPTOBJS=$(OPTUTILS) $(PARSING) $(TYPING) $(COMP) $(ASMCOMP) $(OPTDRIVER)
+
+
+all: runtime runtimeopt ocamlopt.opt libraryopt otherlibrariesopt
+
+runtime:
+	cd byterun; $(MAKE) all
+	if test -f stdlib/libcamlrun.a; then :; else \
+	  ln -s ../byterun/libcamlrun.a stdlib/libcamlrun.a; fi
+
+clean::
+	cd byterun; $(MAKE) clean
+	rm -f stdlib/libcamlrun.a
+	rm -f stdlib/caml
+
+# The runtime system for the native-code compiler
+
+runtimeopt: makeruntimeopt
+	cp asmrun/libasmrun.a stdlib/libasmrun.a
+
+makeruntimeopt:
+	cd asmrun; $(MAKE) all
+
+clean::
+	cd asmrun; $(MAKE) clean
+	rm -f stdlib/libasmrun.a
+
+alldepend::
+	cd asmrun; $(MAKE) depend
+
+ocamlopt.opt: $(OPTOBJS:.cmo=.cmx)
+	$(CAMLOPT) $(LINKFLAGS) -o ocamlopt.opt $(OPTOBJS:.cmo=.cmx)
+	@sed -e 's|@compiler@|ocamlc.opt|' \
+	  driver/ocamlcomp.sh.in > ocamlcomp.sh
+	@chmod +x ocamlcomp.sh
+	@sed -e 's|@compiler@|$$topdir/ocamlopt.opt|' \
+	  driver/ocamlcomp.sh.in > ocamlcompopt.sh
+	@chmod +x ocamlcompopt.sh
+
+partialclean::
+	rm -f ocamlcomp.sh ocamlcompopt.sh ocamlopt.opt
+
+libraryopt:
+	cd stdlib; $(MAKE) allopt
+
+partialclean::
+	cd stdlib; $(MAKE) clean
+
+alldepend::
+	cd stdlib; $(MAKE) depend
+
+ocamlmklib:
+	cd tools; $(MAKE) ocamlmklib
+
+partialclean::
+	cd tools; $(MAKE) clean
+
+
+otherlibrariesopt: ocamlmklib
+	for i in $(OTHERLIBRARIES); do \
+	  (cd otherlibs/$$i; $(MAKE) allopt) || exit $$?; \
+	done
+
+partialclean::
+	for i in $(OTHERLIBRARIES); do \
+	  (cd otherlibs/$$i; $(MAKE) partialclean); \
+	done
+
+
+
+# Installation of the native-code compiler
+install:
+	if test -d $(BINDIR); then : ; else $(MKDIR) $(BINDIR); fi
+	if test -d $(LIBDIR); then : ; else $(MKDIR) $(LIBDIR); fi
+	cp typing/outcometree.cmi typing/outcometree.mli $(LIBDIR)
+	cd byterun; $(MAKE) installopt
+	cd asmrun; $(MAKE) install
+	cd stdlib; $(MAKE) installopt
+	for i in $(OTHERLIBRARIES); \
+	  do (cd otherlibs/$$i; $(MAKE) installopt) || exit $$?; done
+	cp ocamlopt.opt $(BINDIR)/ocamlopt.opt$(EXE)
+	ln -fs $(BINDIR)/ocamlopt.opt $(BINDIR)/ocamlopt
+	cp tools/ocamlmklib $(BINDIR)
+	cp config/Makefile $(LIBDIR)/Makefile.config
+
+clean::
+	for i in $(OTHERLIBRARIES); do (cd otherlibs/$$i; $(MAKE) clean); done
+
+alldepend::
+	for i in $(OTHERLIBRARIES); do (cd otherlibs/$$i; $(MAKE) depend); done
+
+# The configuration file
+
+utils/config.ml: utils/config.mlp config/Makefile
+	@rm -f utils/config.ml
+	sed -e 's|%%LIBDIR%%|$(LIBDIR)|' \
+	    -e 's|%%BYTERUN%%|$(BINDIR)/ocamlrun|' \
+	    -e 's|%%CCOMPTYPE%%|cc|' \
+	    -e 's|%%BYTECC%%|$(BYTECC) $(BYTECCCOMPOPTS) $(SHAREDCCCOMPOPTS)|' \
+	    -e 's|%%NATIVECC%%|$(NATIVECC) $(NATIVECCCOMPOPTS)|' \
+	    -e 's|%%PACKLD%%|$(PACKLD)|' \
+	    -e 's|%%BYTECCLIBS%%|$(BYTECCLIBS)|' \
+	    -e 's|%%NATIVECCLIBS%%|$(NATIVECCLIBS)|' \
+	    -e 's|%%RANLIBCMD%%|$(RANLIBCMD)|' \
+	    -e 's|%%ARCMD%%|$(ARCMD)|' \
+	    -e 's|%%CC_PROFILE%%|$(CC_PROFILE)|' \
+	    -e 's|%%ARCH%%|$(ARCH)|' \
+	    -e 's|%%MODEL%%|$(MODEL)|' \
+	    -e 's|%%SYSTEM%%|$(SYSTEM)|' \
+	    -e 's|%%EXT_OBJ%%|.o|' \
+	    -e 's|%%EXT_ASM%%|.s|' \
+	    -e 's|%%EXT_LIB%%|.a|' \
+	    -e 's|%%EXT_DLL%%|.so|' \
+	    -e 's|%%SYSTHREAD_SUPPORT%%|$(SYSTHREAD_SUPPORT)|' \
+	    -e 's|%%ASM%%|$(ASM)|' \
+	    -e 's|%%MKDLL%%|$(MKDLL)|' \
+	    -e 's|%%MKEXE%%|$(MKEXE)|' \
+	    -e 's|%%MKMAINDLL%%|$(MKMAINDLL)|' \
+	    -e 's|%%ASM_CFI_SUPPORTED%%|$(ASM_CFI_SUPPORTED)|' \
+	    utils/config.mlp > utils/config.ml
+	@chmod -w utils/config.ml
+
+partialclean::
+	rm -f utils/config.ml
+
+beforedepend:: utils/config.ml
+
+partialclean::
+	rm -f myocamlbuild_config.ml tools/myocamlbuild_config.ml
+
+# The parser
+
+parsing/parser.mli parsing/parser.ml: parsing/parser.mly
+	$(CAMLYACC) $(YACCFLAGS) parsing/parser.mly
+
+partialclean::
+	rm -f parsing/parser.mli parsing/parser.ml parsing/parser.output
+
+beforedepend:: parsing/parser.mli parsing/parser.ml
+
+# The lexer
+
+parsing/lexer.ml: parsing/lexer.mll
+	$(CAMLLEX) parsing/lexer.mll
+
+partialclean::
+	rm -f parsing/lexer.ml
+
+beforedepend:: parsing/lexer.ml
+
+# The auxiliary lexer for counting line numbers
+
+parsing/linenum.ml: parsing/linenum.mll
+	$(CAMLLEX) parsing/linenum.mll
+
+partialclean::
+	rm -f parsing/linenum.ml
+
+beforedepend:: parsing/linenum.ml
+
+# The predefined exceptions and primitives
+
+bytecomp/runtimedef.ml: byterun/primitives byterun/fail.h
+	(echo 'let builtin_exceptions = [|'; \
+	 sed -n -e 's|.*/\* \("[A-Za-z_]*"\) \*/$$|  \1;|p' byterun/fail.h | \
+	 sed -e '$$s/;$$//'; \
+	 echo '|]'; \
+	 echo 'let builtin_primitives = [|'; \
+	 sed -e 's/.*/  "&";/' -e '$$s/;$$//' byterun/primitives; \
+	 echo '|]') > bytecomp/runtimedef.ml
+
+partialclean::
+	rm -f bytecomp/runtimedef.ml
+
+beforedepend:: bytecomp/runtimedef.ml
+
+# Choose the right machine-dependent files
+
+# Choose the right machine-dependent files
+
+asmcomp/arch.ml: asmcomp/$(ARCH)/arch.ml
+	ln -s $(ARCH)/arch.ml asmcomp/arch.ml
+
+partialclean::
+	rm -f asmcomp/arch.ml
+
+beforedepend:: asmcomp/arch.ml
+
+asmcomp/proc.ml: asmcomp/$(ARCH)/proc.ml
+	ln -s $(ARCH)/proc.ml asmcomp/proc.ml
+
+partialclean::
+	rm -f asmcomp/proc.ml
+
+beforedepend:: asmcomp/proc.ml
+
+asmcomp/selection.ml: asmcomp/$(ARCH)/selection.ml
+	ln -s $(ARCH)/selection.ml asmcomp/selection.ml
+
+partialclean::
+	rm -f asmcomp/selection.ml
+
+beforedepend:: asmcomp/selection.ml
+
+asmcomp/reload.ml: asmcomp/$(ARCH)/reload.ml
+	ln -s $(ARCH)/reload.ml asmcomp/reload.ml
+
+partialclean::
+	rm -f asmcomp/reload.ml
+
+beforedepend:: asmcomp/reload.ml
+
+asmcomp/scheduling.ml: asmcomp/$(ARCH)/scheduling.ml
+	ln -s $(ARCH)/scheduling.ml asmcomp/scheduling.ml
+
+partialclean::
+	rm -f asmcomp/scheduling.ml
+
+beforedepend:: asmcomp/scheduling.ml
+
+# Preprocess the code emitters
+
+asmcomp/emit.ml: asmcomp/$(ARCH)/emit.mlp tools/cvt_emit
+	$(CAMLRUN) tools/cvt_emit < asmcomp/$(ARCH)/emit.mlp > asmcomp/emit.ml \
+	|| { rm -f asmcomp/emit.ml; exit 2; }
+
+partialclean::
+	rm -f asmcomp/emit.ml
+
+beforedepend:: asmcomp/emit.ml
+
+tools/cvt_emit: tools/cvt_emit.mll
+	cd tools; \
+	$(MAKE) CAMLC="ocamlc" cvt_emit
+
+# Default rules
+
+.SUFFIXES: .ml .mli .cmo .cmi .cmx
+
+.ml.cmo:
+	$(CAMLC) $(COMPFLAGS) -c $<
+
+.mli.cmi:
+	$(CAMLC) $(COMPFLAGS) -c $<
+
+.ml.cmx:
+	$(CAMLOPT) $(COMPFLAGS) -c $<
+
+partialclean::
+	for d in utils parsing typing bytecomp asmcomp driver toplevel tools; \
+	  do rm -f $$d/*.cm[iox] $$d/*.annot $$d/*.[so] $$d/*~; done
+	rm -f *~
+
+depend: beforedepend
+	(for d in utils parsing typing bytecomp asmcomp driver toplevel; \
+	 do $(CAMLDEP) $(DEPFLAGS) $$d/*.mli $$d/*.ml; \
+	 done) > .depend
+
+alldepend:: depend
+
+clean:: partialclean
+
+distclean:
+	./build/distclean.sh
+
+.PHONY: all backup bootstrap camlp4opt camlp4out checkstack clean
+.PHONY: partialclean beforedepend alldepend cleanboot coldstart
+.PHONY: compare core coreall
+.PHONY: coreboot defaultentry depend distclean install installopt
+.PHONY: library library-cross libraryopt ocamlbuild-mixed-boot
+.PHONY: ocamlbuild.byte ocamlbuild.native ocamldebugger ocamldoc
+.PHONY: ocamldoc.opt ocamllex ocamllex.opt ocamltools ocamltools.opt
+.PHONY: ocamlyacc opt-core opt opt.opt otherlibraries
+.PHONY: otherlibrariesopt package-macosx promote promote-cross
+.PHONY: restore runtime runtimeopt makeruntimeopt world world.opt
+
+include .depend
diff -urN ocaml-4.00/asmrun/arm.S ocaml-4.00-android/asmrun/arm.S
--- ocaml-4.00/asmrun/arm.S	2012-04-26 23:18:00.000000000 +0400
+++ ocaml-4.00-android/asmrun/arm.S	2012-05-11 16:15:48.000000000 +0400
@@ -53,7 +53,7 @@
         push    {lr}; \
         bl      __gnu_mcount_nc
 #else
-#define PROFILE
+#define PROFILE 
 #endif
 
 /* Allocation functions and GC interface */
diff -urN ocaml-4.00/asmrun/signals_osdep.h ocaml-4.00-android/asmrun/signals_osdep.h
--- ocaml-4.00/asmrun/signals_osdep.h	2012-04-26 23:18:00.000000000 +0400
+++ ocaml-4.00-android/asmrun/signals_osdep.h	2012-05-11 16:15:48.000000000 +0400
@@ -61,7 +61,7 @@
 
 /****************** ARM, Linux */
 
-#elif defined(TARGET_arm) && (defined(SYS_linux_eabi) || defined(SYS_linux_eabihf))
+#elif defined(TARGET_arm) && (defined(SYS_linux_eabi) || defined(SYS_linux_eabihf)) && !defined(ANDROID)
 
   #include <sys/ucontext.h>
 
diff -urN ocaml-4.00/byterun/Makefile.common ocaml-4.00-android/byterun/Makefile.common
--- ocaml-4.00/byterun/Makefile.common	2012-04-26 23:17:55.000000000 +0400
+++ ocaml-4.00-android/byterun/Makefile.common	2012-05-11 16:15:48.000000000 +0400
@@ -59,6 +59,14 @@
 	  sed -f ../tools/cleanup-header $$i > $(LIBDIR)/caml/$$i; \
 	done
 	cp ld.conf $(LIBDIR)/ld.conf
+
+
+installopt:
+	if test -d $(LIBDIR)/caml; then : ; else mkdir $(LIBDIR)/caml; fi
+	for i in $(PUBLIC_INCLUDES); do \
+	   sed -f ../tools/cleanup-header $$i > $(LIBDIR)/caml/$$i; \
+	 done
+
 .PHONY: install
 
 install:: install-$(RUNTIMED)
diff -urN ocaml-4.00/config/Makefile ocaml-4.00-android/config/Makefile
--- ocaml-4.00/config/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.00-android/config/Makefile	2012-05-15 14:56:04.000000000 +0400
@@ -0,0 +1,76 @@
+# generated by ./configure 
+PREFIX=/usr/local/ocaml/android
+PLATFORM=/Users/serp/android/ndk/platforms/android-8/arch-arm
+SDK=/Users/serp/android/ndk/toolchains/arm-linux-androideabi-4.4.3/prebuilt/darwin-x86
+BINDIR=$(PREFIX)/bin
+LIBDIR=$(PREFIX)/lib/ocaml
+STUBLIBDIR=$(LIBDIR)/stublibs
+MANDIR=$(PREFIX)/man
+MANEXT=1
+RANLIB=$(SDK)/bin/arm-linux-androideabi-ranlib
+RANLIBCMD=$(RANLIB)
+ARCMD=$(SDK)/bin/arm-linux-androideabi-ar
+SHARPBANGSCRIPTS=true
+BNG_ARCH=generic
+BNG_ASM_LEVEL=0
+PTHREAD_LINK=
+LIBBFD_LINK=-lbfd -ldl -liberty -lz
+#-mfloat-abi=softfp -mfpu=vfpv3 
+BYTECC=$(SDK)/bin/arm-linux-androideabi-gcc -march=armv7-a --sysroot=$(PLATFORM)
+BYTECCCOMPOPTS=-fno-defer-pop -Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__ -DANDROID
+BYTECCLINKOPTS= -Wl,-E
+#BYTECCLIBS= -lm  -ldl -lcurses -lpthread
+#BYTECCLIBS= -lm  -ldl -lcurses -lpthread
+BYTECCLIBS= -lm  -ldl 
+BYTECCRPATH=-Wl,-rpath,
+EXE=
+SUPPORTS_SHARED_LIBRARIES=true
+SHAREDCCCOMPOPTS=-fPIC
+MKSHAREDLIBRPATH=-Wl,-rpath,
+NATDYNLINKOPTS=-Wl,-E
+SYSLIB=-l$(1)
+#ml let syslib x = "-l"^x;;
+
+### How to build a static library
+MKLIB=$(ARCMD) rc $(1) $(2); $(RANLIB) $(1)
+####ml let mklib out files opts = Printf.sprintf "$(ARCMD) rc %s %s %s;$(RANLIBCMD) %s" out opts files out;;
+#ml let mklib out files opts = "$(ARCMD) rc " ^ out ^ " " ^ opts ^ " " ^ files ^ "; $(RANLIBCMD) " ^ out;;
+ARCH=arm
+MODEL=armv7
+SYSTEM=linux_eabihf
+NATIVECC=$(BYTECC)
+NATIVECCCOMPOPTS=-Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__ -DANDROID
+NATIVECCPROFOPTS=-Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__ -DANDROID
+NATIVECCLINKOPTS=
+NATIVECCRPATH=-Wl,-rpath,
+NATIVECCLIBS= -lm  -ldl
+ASM=$(NATIVECC) -D__ARM_EABI__ -c 
+ASPP=$(ASM)
+ASPPPROFFLAGS=-DPROFILING
+PROFILING=noprof
+DYNLINKOPTS= -ldl
+OTHERLIBRARIES=unix str num dynlink bigarray threads
+DEBUGGER=ocamldebugger
+CC_PROFILE=-pg
+SYSTHREAD_SUPPORT=false
+PARTIALLD=ld -r
+PACKLD=$(PARTIALLD) $(NATIVECCLINKOPTS) -o\ 
+DLLCCCOMPOPTS=
+IFLEXDIR=
+O=o
+A=a
+SO=so
+EXT_OBJ=.o
+EXT_ASM=.s
+EXT_LIB=.a
+EXT_DLL=.so
+EXTRALIBS=
+CCOMPTYPE=cc
+TOOLCHAIN=cc
+NATDYNLINK=true
+CMXS=cmxs
+MKEXE=$(BYTECC)
+MKDLL=$(NATIVECC) -shared
+MKMAINDLL=$(NATIVECC) -shared
+RUNTIMED=noruntimed
+ASM_CFI_SUPPORTED=true
diff -urN ocaml-4.00/config/m.h ocaml-4.00-android/config/m.h
--- ocaml-4.00/config/m.h	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.00-android/config/m.h	2012-05-11 16:15:48.000000000 +0400
@@ -0,0 +1,16 @@
+#ifndef __PIC__
+#  define ARCH_CODE32
+#endif
+#undef ARCH_SIXTYFOUR
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+#define SIZEOF_PTR 4
+#define SIZEOF_SHORT 2
+#define ARCH_INT64_TYPE long long
+#define ARCH_UINT64_TYPE unsigned long long
+#define ARCH_INT64_PRINTF_FORMAT "ll"
+#undef ARCH_BIG_ENDIAN
+#undef ARCH_ALIGN_DOUBLE
+#undef ARCH_ALIGN_INT64
+#undef NONSTANDARD_DIV_MOD
+#define ASM_CFI_SUPPORTED
diff -urN ocaml-4.00/config/s.h ocaml-4.00-android/config/s.h
--- ocaml-4.00/config/s.h	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.00-android/config/s.h	2012-05-11 16:15:48.000000000 +0400
@@ -0,0 +1,51 @@
+#define OCAML_OS_TYPE "Unix"
+#define OCAML_STDLIB_DIR "/usr/local/ocaml/android/lib"
+#define POSIX_SIGNALS
+#define HAS_C99_FLOAT_OPS
+#define HAS_GETRUSAGE
+#define HAS_TIMES
+#undef HAS_TERMCAP
+#define HAS_SOCKETS
+#define HAS_SOCKLEN_T
+#define HAS_INET_ATON
+#define HAS_IPV6
+#define HAS_UNISTD
+#define HAS_OFF_T
+#define HAS_DIRENT
+#define HAS_REWINDDIR
+#define HAS_LOCKF
+#define HAS_MKFIFO
+#define HAS_GETCWD
+#define HAS_GETWD
+#define HAS_GETPRIORITY
+#define HAS_UTIME
+#define HAS_UTIMES
+#define HAS_DUP2
+#define HAS_FCHMOD
+#define HAS_TRUNCATE
+#define HAS_SYS_SELECT_H
+#define HAS_SELECT
+#define HAS_SYMLINK
+#define HAS_WAITPID
+#define HAS_WAIT4
+#define HAS_GETGROUPS
+#define HAS_SETGROUPS
+#define HAS_INITGROUPS
+#define HAS_TERMIOS
+#define HAS_ASYNC_IO
+#define HAS_SETITIMER
+#define HAS_GETHOSTNAME
+#define HAS_UNAME
+#define HAS_GETTIMEOFDAY
+#define HAS_MKTIME
+#define HAS_SETSID
+#define HAS_PUTENV
+#define HAS_LOCALE
+#define SUPPORT_DYNAMIC_LINKING
+#define HAS_MMAP
+#define HAS_PWRITE
+#define HAS_GETHOSTBYNAME_R 6
+#undef HAS_GETHOSTBYADDR_R
+#undef HAS_STACK_OVERFLOW_DETECTION
+#define HAS_SIGWAIT
+#undef HAS_LIBBFD
diff -urN ocaml-4.00/otherlibs/Makefile.shared ocaml-4.00-android/otherlibs/Makefile.shared
--- ocaml-4.00/otherlibs/Makefile.shared	2012-04-26 23:17:59.000000000 +0400
+++ ocaml-4.00-android/otherlibs/Makefile.shared	2012-05-11 19:01:13.000000000 +0400
@@ -20,7 +20,7 @@
 
 # Compilation options
 CC=$(BYTECC)
-CAMLRUN=$(ROOTDIR)/boot/ocamlrun
+CAMLRUN=ocamlrun
 COMPFLAGS=-warn-error A -g $(EXTRACAMLFLAGS)
 MKLIB=$(CAMLRUN) $(ROOTDIR)/tools/ocamlmklib
 
@@ -51,7 +51,7 @@
 	$(MKLIB) -o $(LIBNAME) -oc $(CLIBNAME) -ocamlopt '$(CAMLOPT)' -linkall $(CAMLOBJS_NAT) $(LINKOPTS)
 
 $(LIBNAME).cmxs: $(LIBNAME).cmxa lib$(CLIBNAME).$(A)
-	$(CAMLOPT) -shared -o $(LIBNAME).cmxs -I . $(LIBNAME).cmxa
+	$(CAMLOPT) -verbose -shared -o $(LIBNAME).cmxs -I . $(LIBNAME).cmxa
 
 lib$(CLIBNAME).$(A): $(COBJS)
 	$(MKLIB) -oc $(CLIBNAME) $(COBJS) $(LDOPTS)
@@ -65,9 +65,13 @@
 	if test -n "$(HEADERS)"; then cp $(HEADERS) $(LIBDIR)/caml/; fi
 
 installopt:
+	cp lib$(CLIBNAME).$(A) $(LIBDIR)/
+	cd $(LIBDIR); $(RANLIB) lib$(CLIBNAME).$(A)
 	cp $(CAMLOBJS_NAT) $(LIBNAME).cmxa $(LIBNAME).$(A) $(LIBDIR)/
 	cd $(LIBDIR); $(RANLIB) $(LIBNAME).a
+	cp $(CMIFILES) $(CMIFILES:.cmi=.mli) $(LIBDIR)/
 	if test -f $(LIBNAME).cmxs; then cp $(LIBNAME).cmxs $(LIBDIR)/; fi
+	if test -n "$(HEADERS)"; then cp $(HEADERS) $(LIBDIR)/caml/; fi
 
 partialclean:
 	rm -f *.cm*
diff -urN ocaml-4.00/otherlibs/dynlink/Makefile ocaml-4.00-android/otherlibs/dynlink/Makefile
--- ocaml-4.00/otherlibs/dynlink/Makefile	2012-04-26 23:17:58.000000000 +0400
+++ ocaml-4.00-android/otherlibs/dynlink/Makefile	2012-05-11 16:15:48.000000000 +0400
@@ -17,7 +17,7 @@
 
 include ../../config/Makefile
 
-CAMLC=../../boot/ocamlrun ../../ocamlc
+CAMLC=../../ocamlcomp.sh
 CAMLOPT=../../ocamlcompopt.sh
 INCLUDES=-I ../../utils -I ../../typing -I ../../bytecomp -I ../../asmcomp
 COMPFLAGS=-warn-error A -I ../../stdlib $(INCLUDES)
diff -urN ocaml-4.00/otherlibs/systhreads/Makefile ocaml-4.00-android/otherlibs/systhreads/Makefile
--- ocaml-4.00/otherlibs/systhreads/Makefile	2012-04-26 23:17:59.000000000 +0400
+++ ocaml-4.00-android/otherlibs/systhreads/Makefile	2012-05-11 16:15:48.000000000 +0400
@@ -17,7 +17,7 @@
 
 CAMLC=../../ocamlcomp.sh -I ../unix
 CAMLOPT=../../ocamlcompopt.sh -I ../unix
-MKLIB=../../boot/ocamlrun ../../tools/ocamlmklib
+MKLIB=../../tools/ocamlmklib
 COMPFLAGS=-warn-error A -g
 
 BYTECODE_C_OBJS=st_stubs_b.o
@@ -61,7 +61,6 @@
 # modular to me this way. -- Alain
 
 
-$(THREAD_OBJS:.cmo=.cmx): ../../ocamlopt
 
 partialclean:
 	rm -f *.cm*
@@ -80,6 +79,10 @@
 	cp threads.h $(LIBDIR)/caml/threads.h
 
 installopt:
+	if test -d $(LIBDIR)/threads; then :; else mkdir $(LIBDIR)/threads; fi
+	cp $(THREAD_OBJS:.cmo=.cmi) $(LIBDIR)/threads
+	cp thread.mli mutex.mli condition.mli event.mli threadUnix.mli $(LIBDIR)
+	cp threads.h $(LIBDIR)/caml/threads.h
 	cp libthreadsnat.a $(LIBDIR)/libthreadsnat.a
 	cd $(LIBDIR); $(RANLIB) libthreadsnat.a
 	cp $(THREAD_OBJS:.cmo=.cmx) threads.cmxa threads.a $(LIBDIR)/threads
diff -urN ocaml-4.00/otherlibs/unix/getpw.c ocaml-4.00-android/otherlibs/unix/getpw.c
--- ocaml-4.00/otherlibs/unix/getpw.c	2012-04-26 23:17:58.000000000 +0400
+++ ocaml-4.00-android/otherlibs/unix/getpw.c	2012-05-11 16:15:48.000000000 +0400
@@ -29,7 +29,7 @@
   Begin_roots5 (name, passwd, gecos, dir, shell);
     name = copy_string(entry->pw_name);
     passwd = copy_string(entry->pw_passwd);
-#ifndef __BEOS__
+#if !defined(__BEOS__) && !defined(ANDROID)
     gecos = copy_string(entry->pw_gecos);
 #else
     gecos = copy_string("");
diff -urN ocaml-4.00/otherlibs/unix/termios.c ocaml-4.00-android/otherlibs/unix/termios.c
--- ocaml-4.00/otherlibs/unix/termios.c	2012-04-26 23:17:58.000000000 +0400
+++ ocaml-4.00-android/otherlibs/unix/termios.c	2012-05-11 16:15:48.000000000 +0400
@@ -265,11 +265,16 @@
   return Val_unit;
 }
 
+#if defined(ANDROID)
+CAMLprim value unix_tcdrain(value fd)
+{ invalid_argument("tcdrain not implemented"); }
+#else
 CAMLprim value unix_tcdrain(value fd)
 {
   if (tcdrain(Int_val(fd)) == -1) uerror("tcdrain", Nothing);
   return Val_unit;
 }
+#endif
 
 static int queue_flag_table[] = {
   TCIFLUSH, TCOFLUSH, TCIOFLUSH
diff -urN ocaml-4.00/stdlib/Makefile ocaml-4.00-android/stdlib/Makefile
--- ocaml-4.00/stdlib/Makefile	2012-04-26 23:17:52.000000000 +0400
+++ ocaml-4.00-android/stdlib/Makefile	2012-05-11 16:15:48.000000000 +0400
@@ -15,7 +15,7 @@
 
 include Makefile.shared
 
-allopt: stdlib.cmxa std_exit.cmx allopt-$(PROFILING)
+allopt: stdlib.cmxa std_exit.cmx camlheader camlheader_ur allopt-$(PROFILING)
 
 allopt-noprof:
 
@@ -26,6 +26,8 @@
 
 installopt-default:
 	cp stdlib.cmxa stdlib.a std_exit.o *.cmx $(LIBDIR)
+	cp stdlib.cmxa stdlib.a std_exit.o *.cmx *.cmi *.mli *.ml camlheader camlheader_ur $(LIBDIR)
+	cp stdlib.cmxa stdlib.a std_exit.o *.cmx $(LIBDIR)
 	cd $(LIBDIR); $(RANLIB) stdlib.a
 
 installopt-noprof:
diff -urN ocaml-4.00/stdlib/Makefile.shared ocaml-4.00-android/stdlib/Makefile.shared
--- ocaml-4.00/stdlib/Makefile.shared	2012-04-26 23:17:52.000000000 +0400
+++ ocaml-4.00-android/stdlib/Makefile.shared	2012-05-11 16:15:48.000000000 +0400
@@ -14,14 +14,12 @@
 # $Id: Makefile.shared 12383 2012-04-19 13:12:23Z xleroy $
 
 include ../config/Makefile
-RUNTIME=../boot/ocamlrun
-COMPILER=../ocamlc
-CAMLC=$(RUNTIME) $(COMPILER)
+RUNTIME=ocamlrun
+CAMLC=ocamlc.opt
 COMPFLAGS=-strict-sequence -g -warn-error A -nostdlib
-OPTCOMPILER=../ocamlopt
-CAMLOPT=$(RUNTIME) $(OPTCOMPILER)
+CAMLOPT=../ocamlopt.opt
 OPTCOMPFLAGS=-warn-error A -nostdlib -g
-CAMLDEP=../boot/ocamlrun ../tools/ocamldep
+CAMLDEP=ocamldep.opt
 
 OBJS=pervasives.cmo $(OTHERS)
 OTHERS=array.cmo list.cmo char.cmo string.cmo sys.cmo \
@@ -80,11 +78,6 @@
 .ml.p.cmx:
 	$(CAMLOPT) $(OPTCOMPFLAGS) `./Compflags $@` -p -c -o $*.p.cmx $<
 
-# Dependencies on the compiler
-$(OBJS) std_exit.cmo: $(COMPILER)
-$(OBJS:.cmo=.cmi) std_exit.cmi: $(COMPILER)
-$(OBJS:.cmo=.cmx) std_exit.cmx: $(OPTCOMPILER)
-$(OBJS:.cmo=.p.cmx) std_exit.p.cmx: $(OPTCOMPILER)
 
 # Dependencies on Pervasives (not tracked by ocamldep)
 $(OBJS) std_exit.cmo: pervasives.cmi
diff -urN ocaml-4.00/stdlib/Makefile.shared.orig ocaml-4.00-android/stdlib/Makefile.shared.orig
--- ocaml-4.00/stdlib/Makefile.shared.orig	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.00-android/stdlib/Makefile.shared.orig	2012-04-26 23:17:52.000000000 +0400
@@ -0,0 +1,105 @@
+#########################################################################
+#                                                                       #
+#                                 OCaml                                 #
+#                                                                       #
+#            Xavier Leroy, projet Cristal, INRIA Rocquencourt           #
+#                                                                       #
+#   Copyright 1999 Institut National de Recherche en Informatique et    #
+#   en Automatique.  All rights reserved.  This file is distributed     #
+#   under the terms of the GNU Library General Public License, with     #
+#   the special exception on linking described in file ../LICENSE.      #
+#                                                                       #
+#########################################################################
+
+# $Id: Makefile.shared 12383 2012-04-19 13:12:23Z xleroy $
+
+include ../config/Makefile
+RUNTIME=../boot/ocamlrun
+COMPILER=../ocamlc
+CAMLC=$(RUNTIME) $(COMPILER)
+COMPFLAGS=-strict-sequence -g -warn-error A -nostdlib
+OPTCOMPILER=../ocamlopt
+CAMLOPT=$(RUNTIME) $(OPTCOMPILER)
+OPTCOMPFLAGS=-warn-error A -nostdlib -g
+CAMLDEP=../boot/ocamlrun ../tools/ocamldep
+
+OBJS=pervasives.cmo $(OTHERS)
+OTHERS=array.cmo list.cmo char.cmo string.cmo sys.cmo \
+  sort.cmo marshal.cmo obj.cmo \
+  int32.cmo int64.cmo nativeint.cmo \
+  lexing.cmo parsing.cmo \
+  set.cmo map.cmo stack.cmo queue.cmo \
+  camlinternalLazy.cmo lazy.cmo stream.cmo \
+  buffer.cmo printf.cmo \
+  arg.cmo printexc.cmo gc.cmo \
+  digest.cmo random.cmo hashtbl.cmo format.cmo scanf.cmo callback.cmo \
+  camlinternalOO.cmo oo.cmo camlinternalMod.cmo \
+  genlex.cmo weak.cmo \
+  filename.cmo complex.cmo \
+  arrayLabels.cmo listLabels.cmo stringLabels.cmo moreLabels.cmo stdLabels.cmo
+
+all: stdlib.cma std_exit.cmo camlheader camlheader_ur
+
+install: install-$(RUNTIMED)
+	cp stdlib.cma std_exit.cmo *.cmi *.mli *.ml camlheader camlheader_ur \
+	  $(LIBDIR)
+
+install-noruntimed:
+.PHONY: install-noruntimed
+
+install-runtimed: camlheaderd
+	cp camlheaderd $(LIBDIR)
+.PHONY: install-runtimed
+
+stdlib.cma: $(OBJS)
+	$(CAMLC) -a -o stdlib.cma $(OBJS)
+
+stdlib.cmxa: $(OBJS:.cmo=.cmx)
+	$(CAMLOPT) -a -o stdlib.cmxa $(OBJS:.cmo=.cmx)
+
+sys.ml: sys.mlp ../VERSION
+	sed -e "s|%%VERSION%%|`sed -e 1q ../VERSION`|" sys.mlp >sys.ml
+
+clean::
+	rm -f sys.ml
+
+clean::
+	rm -f camlheader camlheader_ur camlheaderd
+
+.SUFFIXES: .mli .ml .cmi .cmo .cmx .p.cmx
+
+.mli.cmi:
+	$(CAMLC) $(COMPFLAGS) `./Compflags $@` -c $<
+
+.ml.cmo:
+	$(CAMLC) $(COMPFLAGS) `./Compflags $@` -c $<
+
+.ml.cmx:
+	$(CAMLOPT) $(OPTCOMPFLAGS) `./Compflags $@` -c $<
+
+.ml.p.cmx:
+	$(CAMLOPT) $(OPTCOMPFLAGS) `./Compflags $@` -p -c -o $*.p.cmx $<
+
+# Dependencies on the compiler
+$(OBJS) std_exit.cmo: $(COMPILER)
+$(OBJS:.cmo=.cmi) std_exit.cmi: $(COMPILER)
+$(OBJS:.cmo=.cmx) std_exit.cmx: $(OPTCOMPILER)
+$(OBJS:.cmo=.p.cmx) std_exit.p.cmx: $(OPTCOMPILER)
+
+# Dependencies on Pervasives (not tracked by ocamldep)
+$(OBJS) std_exit.cmo: pervasives.cmi
+$(OTHERS:.cmo=.cmi) std_exit.cmi: pervasives.cmi
+$(OBJS:.cmo=.cmx) std_exit.cmx: pervasives.cmi
+$(OBJS:.cmo=.p.cmx) std_exit.p.cmx: pervasives.cmi
+$(OTHERS:.cmo=.cmx) std_exit.cmx: pervasives.cmx
+$(OTHERS:.cmo=.p.cmx) std_exit.p.cmx: pervasives.cmx
+
+clean::
+	rm -f *.cm* *.$(O) *.$(A)
+	rm -f *~
+
+include .depend
+
+depend:
+	$(CAMLDEP) *.mli *.ml > .depend
+	$(CAMLDEP) *.ml | sed -e 's/\.cmx/.p.cmx/g' >>.depend
diff -urN ocaml-4.00/stdlib/camlinternalOO.ml ocaml-4.00-android/stdlib/camlinternalOO.ml
--- ocaml-4.00/stdlib/camlinternalOO.ml	2012-04-26 23:17:52.000000000 +0400
+++ ocaml-4.00-android/stdlib/camlinternalOO.ml	2012-05-11 16:15:48.000000000 +0400
@@ -80,7 +80,8 @@
   (* reduce to 31 bits *)
   accu := !accu land (1 lsl 31 - 1);
   (* make it signed for 64 bits architectures *)
-  let tag = if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu in
+  let tag = !accu in
+(*   let tag = if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu in *)
   (* Printf.eprintf "%s = %d\n" s tag; flush stderr; *)
   magic tag
 
diff -urN ocaml-4.00/stdlib/pervasives.ml ocaml-4.00-android/stdlib/pervasives.ml
--- ocaml-4.00/stdlib/pervasives.ml	2012-04-26 23:17:52.000000000 +0400
+++ ocaml-4.00-android/stdlib/pervasives.ml	2012-05-15 15:00:15.000000000 +0400
@@ -72,7 +72,7 @@
 external ( lsr ) : int -> int -> int = "%lsrint"
 external ( asr ) : int -> int -> int = "%asrint"
 
-let min_int = 1 lsl (if 1 lsl 31 = 0 then 30 else 62)
+let min_int = 1 lsl 30
 let max_int = min_int - 1
 
 (* Floating-point operations *)
@@ -83,31 +83,29 @@
 external ( -. ) : float -> float -> float = "%subfloat"
 external ( *. ) : float -> float -> float = "%mulfloat"
 external ( /. ) : float -> float -> float = "%divfloat"
-external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
-external exp : float -> float = "caml_exp_float" "exp" "float"
-external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
-external acos : float -> float = "caml_acos_float" "acos" "float"
-external asin : float -> float = "caml_asin_float" "asin" "float"
-external atan : float -> float = "caml_atan_float" "atan" "float"
-external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
-external hypot : float -> float -> float
-               = "caml_hypot_float" "caml_hypot" "float"
-external cos : float -> float = "caml_cos_float" "cos" "float"
-external cosh : float -> float = "caml_cosh_float" "cosh" "float"
-external log : float -> float = "caml_log_float" "log" "float"
-external log10 : float -> float = "caml_log10_float" "log10" "float"
-external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
-external sin : float -> float = "caml_sin_float" "sin" "float"
-external sinh : float -> float = "caml_sinh_float" "sinh" "float"
-external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
-external tan : float -> float = "caml_tan_float" "tan" "float"
-external tanh : float -> float = "caml_tanh_float" "tanh" "float"
-external ceil : float -> float = "caml_ceil_float" "ceil" "float"
-external floor : float -> float = "caml_floor_float" "floor" "float"
+external ( ** ) : float -> float -> float = "caml_power_float" (* "pow" "float" *)
+external exp : float -> float = "caml_exp_float" (* "exp" "float" *)
+external expm1 : float -> float = "caml_expm1_float" (* "caml_expm1" "float" *)
+external acos : float -> float = "caml_acos_float" (* "acos" "float" *)
+external asin : float -> float = "caml_asin_float" (* "asin" "float" *)
+external atan : float -> float = "caml_atan_float" (* "atan" "float" *)
+external atan2 : float -> float -> float = "caml_atan2_float" (* "atan2" "float" *)
+external hypot : float -> float -> float = "caml_hypot_float" (* "caml_hypot" "float" *)
+external cos : float -> float = "caml_cos_float" (* "cos" "float" *)
+external cosh : float -> float = "caml_cosh_float" (* "cosh" "float" *)
+external log : float -> float = "caml_log_float" (* "log" "float" *)
+external log10 : float -> float = "caml_log10_float" (* "log10" "float" *)
+external log1p : float -> float = "caml_log1p_float" (* "caml_log1p" "float" *)
+external sin : float -> float = "caml_sin_float" (* "sin" "float" *)
+external sinh : float -> float = "caml_sinh_float" (* "sinh" "float" *)
+external sqrt : float -> float = "caml_sqrt_float" (* "sqrt" "float" *)
+external tan : float -> float = "caml_tan_float" (* "tan" "float" *)
+external tanh : float -> float = "caml_tanh_float" (* "tanh" "float" *)
+external ceil : float -> float = "caml_ceil_float" (* "ceil" "float" *)
+external floor : float -> float = "caml_floor_float" (* "floor" "float" *)
 external abs_float : float -> float = "%absfloat"
-external copysign : float -> float -> float
-                  = "caml_copysign_float" "caml_copysign" "float"
-external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
+external copysign : float -> float -> float = "caml_copysign_float" (* "caml_copysign" "float" *)
+external mod_float : float -> float -> float = "caml_fmod_float" (* "fmod" "float" *)
 external frexp : float -> float * int = "caml_frexp_float"
 external ldexp : float -> int -> float = "caml_ldexp_float"
 external modf : float -> float * float = "caml_modf_float"
diff -urN ocaml-4.00/stdlib/pervasives.ml.orig ocaml-4.00-android/stdlib/pervasives.ml.orig
--- ocaml-4.00/stdlib/pervasives.ml.orig	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.00-android/stdlib/pervasives.ml.orig	2012-05-15 14:59:46.000000000 +0400
@@ -0,0 +1,457 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                                OCaml                                *)
+(*                                                                     *)
+(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                     *)
+(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
+(*  en Automatique.  All rights reserved.  This file is distributed    *)
+(*  under the terms of the GNU Library General Public License, with    *)
+(*  the special exception on linking described in file ../LICENSE.     *)
+(*                                                                     *)
+(***********************************************************************)
+
+(* $Id: pervasives.ml 12019 2012-01-12 15:46:51Z doligez $ *)
+
+(* type 'a option = None | Some of 'a *)
+
+(* Exceptions *)
+
+external raise : exn -> 'a = "%raise"
+
+let failwith s = raise(Failure s)
+let invalid_arg s = raise(Invalid_argument s)
+
+exception Exit
+
+(* Comparisons *)
+
+external ( = ) : 'a -> 'a -> bool = "%equal"
+external ( <> ) : 'a -> 'a -> bool = "%notequal"
+external ( < ) : 'a -> 'a -> bool = "%lessthan"
+external ( > ) : 'a -> 'a -> bool = "%greaterthan"
+external ( <= ) : 'a -> 'a -> bool = "%lessequal"
+external ( >= ) : 'a -> 'a -> bool = "%greaterequal"
+external compare : 'a -> 'a -> int = "%compare"
+
+let min x y = if x <= y then x else y
+let max x y = if x >= y then x else y
+
+external ( == ) : 'a -> 'a -> bool = "%eq"
+external ( != ) : 'a -> 'a -> bool = "%noteq"
+
+(* Boolean operations *)
+
+external not : bool -> bool = "%boolnot"
+external ( & ) : bool -> bool -> bool = "%sequand"
+external ( && ) : bool -> bool -> bool = "%sequand"
+external ( or ) : bool -> bool -> bool = "%sequor"
+external ( || ) : bool -> bool -> bool = "%sequor"
+
+(* Integer operations *)
+
+external ( ~- ) : int -> int = "%negint"
+external ( ~+ ) : int -> int = "%identity"
+external succ : int -> int = "%succint"
+external pred : int -> int = "%predint"
+external ( + ) : int -> int -> int = "%addint"
+external ( - ) : int -> int -> int = "%subint"
+external ( *  ) : int -> int -> int = "%mulint"
+external ( / ) : int -> int -> int = "%divint"
+external ( mod ) : int -> int -> int = "%modint"
+
+let abs x = if x >= 0 then x else -x
+
+external ( land ) : int -> int -> int = "%andint"
+external ( lor ) : int -> int -> int = "%orint"
+external ( lxor ) : int -> int -> int = "%xorint"
+
+let lnot x = x lxor (-1)
+
+external ( lsl ) : int -> int -> int = "%lslint"
+external ( lsr ) : int -> int -> int = "%lsrint"
+external ( asr ) : int -> int -> int = "%asrint"
+
+let min_int = 1 lsl 30
+let max_int = min_int - 1
+
+(* Floating-point operations *)
+
+external ( ~-. ) : float -> float = "%negfloat"
+external ( ~+. ) : float -> float = "%identity"
+external ( +. ) : float -> float -> float = "%addfloat"
+external ( -. ) : float -> float -> float = "%subfloat"
+external ( *. ) : float -> float -> float = "%mulfloat"
+external ( /. ) : float -> float -> float = "%divfloat"
+external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
+external exp : float -> float = "caml_exp_float" "exp" "float"
+external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
+external acos : float -> float = "caml_acos_float" "acos" "float"
+external asin : float -> float = "caml_asin_float" "asin" "float"
+external atan : float -> float = "caml_atan_float" "atan" "float"
+external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
+external hypot : float -> float -> float
+               = "caml_hypot_float" "caml_hypot" "float"
+external cos : float -> float = "caml_cos_float" "cos" "float"
+external cosh : float -> float = "caml_cosh_float" "cosh" "float"
+external log : float -> float = "caml_log_float" "log" "float"
+external log10 : float -> float = "caml_log10_float" "log10" "float"
+external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
+external sin : float -> float = "caml_sin_float" "sin" "float"
+external sinh : float -> float = "caml_sinh_float" "sinh" "float"
+external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
+external tan : float -> float = "caml_tan_float" "tan" "float"
+external tanh : float -> float = "caml_tanh_float" "tanh" "float"
+external ceil : float -> float = "caml_ceil_float" "ceil" "float"
+external floor : float -> float = "caml_floor_float" "floor" "float"
+external abs_float : float -> float = "%absfloat"
+external copysign : float -> float -> float
+                  = "caml_copysign_float" "caml_copysign" "float"
+external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
+external frexp : float -> float * int = "caml_frexp_float"
+external ldexp : float -> int -> float = "caml_ldexp_float"
+external modf : float -> float * float = "caml_modf_float"
+external float : int -> float = "%floatofint"
+external float_of_int : int -> float = "%floatofint"
+external truncate : float -> int = "%intoffloat"
+external int_of_float : float -> int = "%intoffloat"
+external float_of_bits : int64 -> float = "caml_int64_float_of_bits"
+let infinity =
+  float_of_bits 0x7F_F0_00_00_00_00_00_00L
+let neg_infinity =
+  float_of_bits 0xFF_F0_00_00_00_00_00_00L
+let nan =
+  float_of_bits 0x7F_F0_00_00_00_00_00_01L
+let max_float =
+  float_of_bits 0x7F_EF_FF_FF_FF_FF_FF_FFL
+let min_float =
+  float_of_bits 0x00_10_00_00_00_00_00_00L
+let epsilon_float =
+  float_of_bits 0x3C_B0_00_00_00_00_00_00L
+
+type fpclass =
+    FP_normal
+  | FP_subnormal
+  | FP_zero
+  | FP_infinite
+  | FP_nan
+external classify_float : float -> fpclass = "caml_classify_float"
+
+(* String operations -- more in module String *)
+
+external string_length : string -> int = "%string_length"
+external string_create : int -> string = "caml_create_string"
+external string_blit : string -> int -> string -> int -> int -> unit
+                     = "caml_blit_string" "noalloc"
+
+let ( ^ ) s1 s2 =
+  let l1 = string_length s1 and l2 = string_length s2 in
+  let s = string_create (l1 + l2) in
+  string_blit s1 0 s 0 l1;
+  string_blit s2 0 s l1 l2;
+  s
+
+(* Character operations -- more in module Char *)
+
+external int_of_char : char -> int = "%identity"
+external unsafe_char_of_int : int -> char = "%identity"
+let char_of_int n =
+  if n < 0 || n > 255 then invalid_arg "char_of_int" else unsafe_char_of_int n
+
+(* Unit operations *)
+
+external ignore : 'a -> unit = "%ignore"
+
+(* Pair operations *)
+
+external fst : 'a * 'b -> 'a = "%field0"
+external snd : 'a * 'b -> 'b = "%field1"
+
+(* String conversion functions *)
+
+external format_int : string -> int -> string = "caml_format_int"
+external format_float : string -> float -> string = "caml_format_float"
+
+let string_of_bool b =
+  if b then "true" else "false"
+let bool_of_string = function
+  | "true" -> true
+  | "false" -> false
+  | _ -> invalid_arg "bool_of_string"
+
+let string_of_int n =
+  format_int "%d" n
+
+external int_of_string : string -> int = "caml_int_of_string"
+
+module String = struct
+  external get : string -> int -> char = "%string_safe_get"
+end
+
+let valid_float_lexem s =
+  let l = string_length s in
+  let rec loop i =
+    if i >= l then s ^ "." else
+    match s.[i] with
+    | '0' .. '9' | '-' -> loop (i + 1)
+    | _ -> s
+  in
+  loop 0
+;;
+
+let string_of_float f = valid_float_lexem (format_float "%.12g" f);;
+
+external float_of_string : string -> float = "caml_float_of_string"
+
+(* List operations -- more in module List *)
+
+let rec ( @ ) l1 l2 =
+  match l1 with
+    [] -> l2
+  | hd :: tl -> hd :: (tl @ l2)
+
+(* I/O operations *)
+
+type in_channel
+type out_channel
+
+external open_descriptor_out : int -> out_channel
+                             = "caml_ml_open_descriptor_out"
+external open_descriptor_in : int -> in_channel = "caml_ml_open_descriptor_in"
+
+let stdin = open_descriptor_in 0
+let stdout = open_descriptor_out 1
+let stderr = open_descriptor_out 2
+
+(* General output functions *)
+
+type open_flag =
+    Open_rdonly | Open_wronly | Open_append
+  | Open_creat | Open_trunc | Open_excl
+  | Open_binary | Open_text | Open_nonblock
+
+external open_desc : string -> open_flag list -> int -> int = "caml_sys_open"
+
+let open_out_gen mode perm name =
+  open_descriptor_out(open_desc name mode perm)
+
+let open_out name =
+  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_text] 0o666 name
+
+let open_out_bin name =
+  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_binary] 0o666 name
+
+external flush : out_channel -> unit = "caml_ml_flush"
+
+external out_channels_list : unit -> out_channel list
+                           = "caml_ml_out_channels_list"
+
+let flush_all () =
+  let rec iter = function
+      [] -> ()
+    | a :: l -> (try flush a with _ -> ()); iter l
+  in iter (out_channels_list ())
+
+external unsafe_output : out_channel -> string -> int -> int -> unit
+                       = "caml_ml_output"
+
+external output_char : out_channel -> char -> unit = "caml_ml_output_char"
+
+let output_string oc s =
+  unsafe_output oc s 0 (string_length s)
+
+let output oc s ofs len =
+  if ofs < 0 || len < 0 || ofs > string_length s - len
+  then invalid_arg "output"
+  else unsafe_output oc s ofs len
+
+external output_byte : out_channel -> int -> unit = "caml_ml_output_char"
+external output_binary_int : out_channel -> int -> unit = "caml_ml_output_int"
+
+external marshal_to_channel : out_channel -> 'a -> unit list -> unit
+     = "caml_output_value"
+let output_value chan v = marshal_to_channel chan v []
+
+external seek_out : out_channel -> int -> unit = "caml_ml_seek_out"
+external pos_out : out_channel -> int = "caml_ml_pos_out"
+external out_channel_length : out_channel -> int = "caml_ml_channel_size"
+external close_out_channel : out_channel -> unit = "caml_ml_close_channel"
+let close_out oc = flush oc; close_out_channel oc
+let close_out_noerr oc =
+  (try flush oc with _ -> ());
+  (try close_out_channel oc with _ -> ())
+external set_binary_mode_out : out_channel -> bool -> unit
+                             = "caml_ml_set_binary_mode"
+
+(* General input functions *)
+
+let open_in_gen mode perm name =
+  open_descriptor_in(open_desc name mode perm)
+
+let open_in name =
+  open_in_gen [Open_rdonly; Open_text] 0 name
+
+let open_in_bin name =
+  open_in_gen [Open_rdonly; Open_binary] 0 name
+
+external input_char : in_channel -> char = "caml_ml_input_char"
+
+external unsafe_input : in_channel -> string -> int -> int -> int
+                      = "caml_ml_input"
+
+let input ic s ofs len =
+  if ofs < 0 || len < 0 || ofs > string_length s - len
+  then invalid_arg "input"
+  else unsafe_input ic s ofs len
+
+let rec unsafe_really_input ic s ofs len =
+  if len <= 0 then () else begin
+    let r = unsafe_input ic s ofs len in
+    if r = 0
+    then raise End_of_file
+    else unsafe_really_input ic s (ofs + r) (len - r)
+  end
+
+let really_input ic s ofs len =
+  if ofs < 0 || len < 0 || ofs > string_length s - len
+  then invalid_arg "really_input"
+  else unsafe_really_input ic s ofs len
+
+external input_scan_line : in_channel -> int = "caml_ml_input_scan_line"
+
+let input_line chan =
+  let rec build_result buf pos = function
+    [] -> buf
+  | hd :: tl ->
+      let len = string_length hd in
+      string_blit hd 0 buf (pos - len) len;
+      build_result buf (pos - len) tl in
+  let rec scan accu len =
+    let n = input_scan_line chan in
+    if n = 0 then begin                   (* n = 0: we are at EOF *)
+      match accu with
+        [] -> raise End_of_file
+      | _  -> build_result (string_create len) len accu
+    end else if n > 0 then begin          (* n > 0: newline found in buffer *)
+      let res = string_create (n - 1) in
+      ignore (unsafe_input chan res 0 (n - 1));
+      ignore (input_char chan);           (* skip the newline *)
+      match accu with
+        [] -> res
+      |  _ -> let len = len + n - 1 in
+              build_result (string_create len) len (res :: accu)
+    end else begin                        (* n < 0: newline not found *)
+      let beg = string_create (-n) in
+      ignore(unsafe_input chan beg 0 (-n));
+      scan (beg :: accu) (len - n)
+    end
+  in scan [] 0
+
+external input_byte : in_channel -> int = "caml_ml_input_char"
+external input_binary_int : in_channel -> int = "caml_ml_input_int"
+external input_value : in_channel -> 'a = "caml_input_value"
+external seek_in : in_channel -> int -> unit = "caml_ml_seek_in"
+external pos_in : in_channel -> int = "caml_ml_pos_in"
+external in_channel_length : in_channel -> int = "caml_ml_channel_size"
+external close_in : in_channel -> unit = "caml_ml_close_channel"
+let close_in_noerr ic = (try close_in ic with _ -> ());;
+external set_binary_mode_in : in_channel -> bool -> unit
+                            = "caml_ml_set_binary_mode"
+
+(* Output functions on standard output *)
+
+let print_char c = output_char stdout c
+let print_string s = output_string stdout s
+let print_int i = output_string stdout (string_of_int i)
+let print_float f = output_string stdout (string_of_float f)
+let print_endline s =
+  output_string stdout s; output_char stdout '\n'; flush stdout
+let print_newline () = output_char stdout '\n'; flush stdout
+
+(* Output functions on standard error *)
+
+let prerr_char c = output_char stderr c
+let prerr_string s = output_string stderr s
+let prerr_int i = output_string stderr (string_of_int i)
+let prerr_float f = output_string stderr (string_of_float f)
+let prerr_endline s =
+  output_string stderr s; output_char stderr '\n'; flush stderr
+let prerr_newline () = output_char stderr '\n'; flush stderr
+
+(* Input functions on standard input *)
+
+let read_line () = flush stdout; input_line stdin
+let read_int () = int_of_string(read_line())
+let read_float () = float_of_string(read_line())
+
+(* Operations on large files *)
+
+module LargeFile =
+  struct
+    external seek_out : out_channel -> int64 -> unit = "caml_ml_seek_out_64"
+    external pos_out : out_channel -> int64 = "caml_ml_pos_out_64"
+    external out_channel_length : out_channel -> int64
+                                = "caml_ml_channel_size_64"
+    external seek_in : in_channel -> int64 -> unit = "caml_ml_seek_in_64"
+    external pos_in : in_channel -> int64 = "caml_ml_pos_in_64"
+    external in_channel_length : in_channel -> int64 = "caml_ml_channel_size_64"
+  end
+
+(* References *)
+
+type 'a ref = { mutable contents : 'a }
+external ref : 'a -> 'a ref = "%makemutable"
+external ( ! ) : 'a ref -> 'a = "%field0"
+external ( := ) : 'a ref -> 'a -> unit = "%setfield0"
+external incr : int ref -> unit = "%incr"
+external decr : int ref -> unit = "%decr"
+
+(* Formats *)
+type ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6
+
+type ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4
+
+external format_of_string :
+ ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+ ('a, 'b, 'c, 'd, 'e, 'f) format6 = "%identity"
+
+external format_to_string :
+ ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string = "%identity"
+external string_to_format :
+ string -> ('a, 'b, 'c, 'd, 'e, 'f) format6 = "%identity"
+
+let (( ^^ ) :
+      ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+      ('f, 'b, 'c, 'e, 'g, 'h) format6 ->
+      ('a, 'b, 'c, 'd, 'g, 'h) format6) =
+  fun fmt1 fmt2 ->
+    string_to_format (format_to_string fmt1 ^ "%," ^ format_to_string fmt2)
+;;
+
+let string_of_format fmt =
+  let s = format_to_string fmt in
+  let l = string_length s in
+  let r = string_create l in
+  string_blit s 0 r 0 l;
+  r
+
+(* Miscellaneous *)
+
+external sys_exit : int -> 'a = "caml_sys_exit"
+
+let exit_function = ref flush_all
+
+let at_exit f =
+  let g = !exit_function in
+  exit_function := (fun () -> f(); g())
+
+let do_at_exit () = (!exit_function) ()
+
+let exit retcode =
+  do_at_exit ();
+  sys_exit retcode
+
+external register_named_value : string -> 'a -> unit
+                              = "caml_register_named_value"
+
+let _ = register_named_value "Pervasives.do_at_exit" do_at_exit
diff -urN ocaml-4.00/stdlib/pervasives.mli ocaml-4.00-android/stdlib/pervasives.mli
--- ocaml-4.00/stdlib/pervasives.mli	2012-05-05 17:00:39.000000000 +0400
+++ ocaml-4.00-android/stdlib/pervasives.mli	2012-05-15 15:00:17.000000000 +0400
@@ -261,82 +261,81 @@
 external ( /. ) : float -> float -> float = "%divfloat"
 (** Floating-point division. *)
 
-external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
+external ( ** ) : float -> float -> float = "caml_power_float" (* "pow" "float" *)
 (** Exponentiation. *)
 
-external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
+external sqrt : float -> float = "caml_sqrt_float" (* "sqrt" "float" *)
 (** Square root. *)
 
-external exp : float -> float = "caml_exp_float" "exp" "float"
+external exp : float -> float = "caml_exp_float" (* "exp" "float" *)
 (** Exponential. *)
 
-external log : float -> float = "caml_log_float" "log" "float"
+external log : float -> float = "caml_log_float" (* "log" "float" *)
 (** Natural logarithm. *)
 
-external log10 : float -> float = "caml_log10_float" "log10" "float"
+external log10 : float -> float = "caml_log10_float" (* "log10" "float" *)
 (** Base 10 logarithm. *)
 
-external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
+external expm1 : float -> float = "caml_expm1_float" (* "caml_expm1" "float" *)
 (** [expm1 x] computes [exp x -. 1.0], giving numerically-accurate results
     even if [x] is close to [0.0].
     @since 3.12.0
 *)
 
-external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
+external log1p : float -> float = "caml_log1p_float" (* "caml_log1p" "float" *)
 (** [log1p x] computes [log(1.0 +. x)] (natural logarithm),
     giving numerically-accurate results even if [x] is close to [0.0].
     @since 3.12.0
 *)
 
-external cos : float -> float = "caml_cos_float" "cos" "float"
+external cos : float -> float = "caml_cos_float" (* "cos" "float" *)
 (** Cosine.  Argument is in radians. *)
 
-external sin : float -> float = "caml_sin_float" "sin" "float"
+external sin : float -> float = "caml_sin_float" (* "sin" "float" *)
 (** Sine.  Argument is in radians. *)
 
-external tan : float -> float = "caml_tan_float" "tan" "float"
+external tan : float -> float = "caml_tan_float" (* "tan" "float" *)
 (** Tangent.  Argument is in radians. *)
 
-external acos : float -> float = "caml_acos_float" "acos" "float"
+external acos : float -> float = "caml_acos_float" (* "acos" "float" *)
 (** Arc cosine.  The argument must fall within the range [[-1.0, 1.0]].
     Result is in radians and is between [0.0] and [pi]. *)
 
-external asin : float -> float = "caml_asin_float" "asin" "float"
+external asin : float -> float = "caml_asin_float" (* "asin" "float" *)
 (** Arc sine.  The argument must fall within the range [[-1.0, 1.0]].
     Result is in radians and is between [-pi/2] and [pi/2]. *)
 
-external atan : float -> float = "caml_atan_float" "atan" "float"
+external atan : float -> float = "caml_atan_float" (* "atan" "float" *)
 (** Arc tangent.
     Result is in radians and is between [-pi/2] and [pi/2]. *)
 
-external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
+external atan2 : float -> float -> float = "caml_atan2_float" (* "atan2" "float" *) 
 (** [atan2 y x] returns the arc tangent of [y /. x].  The signs of [x]
     and [y] are used to determine the quadrant of the result.
     Result is in radians and is between [-pi] and [pi]. *)
 
-external hypot : float -> float -> float
-               = "caml_hypot_float" "caml_hypot" "float"
+external hypot : float -> float -> float = "caml_hypot_float" (* "caml_hypot" "float" *)
 (** [hypot x y] returns [sqrt(x *. x + y *. y)], that is, the length
   of the hypotenuse of a right-angled triangle with sides of length
   [x] and [y], or, equivalently, the distance of the point [(x,y)]
   to origin.
   @since 4.00.0  *)
 
-external cosh : float -> float = "caml_cosh_float" "cosh" "float"
+external cosh : float -> float = "caml_cosh_float" (* "cosh" "float" *)
 (** Hyperbolic cosine.  Argument is in radians. *)
 
-external sinh : float -> float = "caml_sinh_float" "sinh" "float"
+external sinh : float -> float = "caml_sinh_float" (* "sinh" "float" *)
 (** Hyperbolic sine.  Argument is in radians. *)
 
-external tanh : float -> float = "caml_tanh_float" "tanh" "float"
+external tanh : float -> float = "caml_tanh_float" (* "tanh" "float" *)
 (** Hyperbolic tangent.  Argument is in radians. *)
 
-external ceil : float -> float = "caml_ceil_float" "ceil" "float"
+external ceil : float -> float = "caml_ceil_float" (* "ceil" "float" *)
 (** Round above to an integer value.
     [ceil f] returns the least integer value greater than or equal to [f].
     The result is returned as a float. *)
 
-external floor : float -> float = "caml_floor_float" "floor" "float"
+external floor : float -> float = "caml_floor_float" (* "floor" "float" *)
 (** Round below to an integer value.
     [floor f] returns the greatest integer value less than or
     equal to [f].
@@ -346,14 +345,15 @@
 (** [abs_float f] returns the absolute value of [f]. *)
 
 external copysign : float -> float -> float
-                  = "caml_copysign_float" "caml_copysign" "float"
+                  = "caml_copysign_float" (* "caml_copysign" "float" *)
 (** [copysign x y] returns a float whose absolute value is that of [x]
   and whose sign is that of [y].  If [x] is [nan], returns [nan].
   If [y] is [nan], returns either [x] or [-. x], but it is not
   specified which.
   @since 4.00.0  *)
 
-external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
+external mod_float : float -> float -> float = "caml_fmod_float" (* "fmod"
+"float" *)
 (** [mod_float a b] returns the remainder of [a] with respect to
    [b].  The returned value is [a -. n *. b], where [n]
    is the quotient [a /. b] rounded towards zero to an integer. *)
diff -urN ocaml-4.00/stdlib/pervasives.mli.orig ocaml-4.00-android/stdlib/pervasives.mli.orig
--- ocaml-4.00/stdlib/pervasives.mli.orig	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.00-android/stdlib/pervasives.mli.orig	2012-05-15 14:59:55.000000000 +0400
@@ -0,0 +1,937 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                                OCaml                                *)
+(*                                                                     *)
+(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                     *)
+(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
+(*  en Automatique.  All rights reserved.  This file is distributed    *)
+(*  under the terms of the GNU Library General Public License, with    *)
+(*  the special exception on linking described in file ../LICENSE.     *)
+(*                                                                     *)
+(***********************************************************************)
+
+(* $Id: pervasives.mli 12416 2012-05-02 14:39:52Z doligez $ *)
+
+(** The initially opened module.
+
+   This module provides the basic operations over the built-in types
+   (numbers, booleans, strings, exceptions, references, lists, arrays,
+   input-output channels, ...).
+
+   This module is automatically opened at the beginning of each compilation.
+   All components of this module can therefore be referred by their short
+   name, without prefixing them by [Pervasives].
+*)
+
+
+(** {6 Exceptions} *)
+
+external raise : exn -> 'a = "%raise"
+(** Raise the given exception value *)
+
+val invalid_arg : string -> 'a
+(** Raise exception [Invalid_argument] with the given string. *)
+
+val failwith : string -> 'a
+(** Raise exception [Failure] with the given string. *)
+
+exception Exit
+(** The [Exit] exception is not raised by any library function.  It is
+    provided for use in your programs.*)
+
+
+(** {6 Comparisons} *)
+
+external ( = ) : 'a -> 'a -> bool = "%equal"
+(** [e1 = e2] tests for structural equality of [e1] and [e2].
+   Mutable structures (e.g. references and arrays) are equal
+   if and only if their current contents are structurally equal,
+   even if the two mutable objects are not the same physical object.
+   Equality between functional values raises [Invalid_argument].
+   Equality between cyclic data structures may not terminate. *)
+
+external ( <> ) : 'a -> 'a -> bool = "%notequal"
+(** Negation of {!Pervasives.( = )}. *)
+
+external ( < ) : 'a -> 'a -> bool = "%lessthan"
+(** See {!Pervasives.( >= )}. *)
+
+external ( > ) : 'a -> 'a -> bool = "%greaterthan"
+(** See {!Pervasives.( >= )}. *)
+
+external ( <= ) : 'a -> 'a -> bool = "%lessequal"
+(** See {!Pervasives.( >= )}. *)
+
+external ( >= ) : 'a -> 'a -> bool = "%greaterequal"
+(** Structural ordering functions. These functions coincide with
+   the usual orderings over integers, characters, strings
+   and floating-point numbers, and extend them to a
+   total ordering over all types.
+   The ordering is compatible with [( = )]. As in the case
+   of [( = )], mutable structures are compared by contents.
+   Comparison between functional values raises [Invalid_argument].
+   Comparison between cyclic structures may not terminate. *)
+
+external compare : 'a -> 'a -> int = "%compare"
+(** [compare x y] returns [0] if [x] is equal to [y],
+   a negative integer if [x] is less than [y], and a positive integer
+   if [x] is greater than [y].  The ordering implemented by [compare]
+   is compatible with the comparison predicates [=], [<] and [>]
+   defined above,  with one difference on the treatment of the float value
+   {!Pervasives.nan}.  Namely, the comparison predicates treat [nan]
+   as different from any other float value, including itself;
+   while [compare] treats [nan] as equal to itself and less than any
+   other float value.  This treatment of [nan] ensures that [compare]
+   defines a total ordering relation.
+
+   [compare] applied to functional values may raise [Invalid_argument].
+   [compare] applied to cyclic structures may not terminate.
+
+   The [compare] function can be used as the comparison function
+   required by the {!Set.Make} and {!Map.Make} functors, as well as
+   the {!List.sort} and {!Array.sort} functions. *)
+
+val min : 'a -> 'a -> 'a
+(** Return the smaller of the two arguments.
+    The result is unspecified if one of the arguments contains
+    the float value [nan]. *)
+
+val max : 'a -> 'a -> 'a
+(** Return the greater of the two arguments.
+    The result is unspecified if one of the arguments contains
+    the float value [nan]. *)
+
+external ( == ) : 'a -> 'a -> bool = "%eq"
+(** [e1 == e2] tests for physical equality of [e1] and [e2].
+   On mutable types such as references, arrays, strings, records with
+   mutable fields and objects with mutable instance variables,
+   [e1 == e2] is true if and only if physical modification of [e1]
+   also affects [e2].
+   On non-mutable types, the behavior of [( == )] is
+   implementation-dependent; however, it is guaranteed that
+   [e1 == e2] implies [compare e1 e2 = 0]. *)
+
+external ( != ) : 'a -> 'a -> bool = "%noteq"
+(** Negation of {!Pervasives.( == )}. *)
+
+
+(** {6 Boolean operations} *)
+
+external not : bool -> bool = "%boolnot"
+(** The boolean negation. *)
+
+external ( && ) : bool -> bool -> bool = "%sequand"
+(** The boolean ``and''. Evaluation is sequential, left-to-right:
+   in [e1 && e2], [e1] is evaluated first, and if it returns [false],
+   [e2] is not evaluated at all. *)
+
+external ( & ) : bool -> bool -> bool = "%sequand"
+(** @deprecated {!Pervasives.( && )} should be used instead. *)
+
+external ( || ) : bool -> bool -> bool = "%sequor"
+(** The boolean ``or''. Evaluation is sequential, left-to-right:
+   in [e1 || e2], [e1] is evaluated first, and if it returns [true],
+   [e2] is not evaluated at all. *)
+
+external ( or ) : bool -> bool -> bool = "%sequor"
+(** @deprecated {!Pervasives.( || )} should be used instead.*)
+
+
+(** {6 Integer arithmetic} *)
+
+(** Integers are 31 bits wide (or 63 bits on 64-bit processors).
+   All operations are taken modulo 2{^31} (or 2{^63}).
+   They do not fail on overflow. *)
+
+external ( ~- ) : int -> int = "%negint"
+(** Unary negation. You can also write [- e] instead of [~- e]. *)
+
+external ( ~+ ) : int -> int = "%identity"
+(** Unary addition. You can also write [+ e] instead of [~+ e].
+    @since 3.12.0
+*)
+
+external succ : int -> int = "%succint"
+(** [succ x] is [x + 1]. *)
+
+external pred : int -> int = "%predint"
+(** [pred x] is [x - 1]. *)
+
+external ( + ) : int -> int -> int = "%addint"
+(** Integer addition. *)
+
+external ( - ) : int -> int -> int = "%subint"
+(** Integer subtraction. *)
+
+external ( * ) : int -> int -> int = "%mulint"
+(** Integer multiplication. *)
+
+external ( / ) : int -> int -> int = "%divint"
+(** Integer division.
+   Raise [Division_by_zero] if the second argument is 0.
+   Integer division rounds the real quotient of its arguments towards zero.
+   More precisely, if [x >= 0] and [y > 0], [x / y] is the greatest integer
+   less than or equal to the real quotient of [x] by [y].  Moreover,
+   [(- x) / y = x / (- y) = - (x / y)].  *)
+
+external ( mod ) : int -> int -> int = "%modint"
+(** Integer remainder.  If [y] is not zero, the result
+   of [x mod y] satisfies the following properties:
+   [x = (x / y) * y + x mod y] and
+   [abs(x mod y) <= abs(y) - 1].
+   If [y = 0], [x mod y] raises [Division_by_zero].
+   Note that [x mod y] is negative only if [x < 0].
+   Raise [Division_by_zero] if [y] is zero. *)
+
+val abs : int -> int
+(** Return the absolute value of the argument.  Note that this may be
+  negative if the argument is [min_int]. *)
+
+val max_int : int
+(** The greatest representable integer. *)
+
+val min_int : int
+(** The smallest representable integer. *)
+
+
+(** {7 Bitwise operations} *)
+
+external ( land ) : int -> int -> int = "%andint"
+(** Bitwise logical and. *)
+
+external ( lor ) : int -> int -> int = "%orint"
+(** Bitwise logical or. *)
+
+external ( lxor ) : int -> int -> int = "%xorint"
+(** Bitwise logical exclusive or. *)
+
+val lnot : int -> int
+(** Bitwise logical negation. *)
+
+external ( lsl ) : int -> int -> int = "%lslint"
+(** [n lsl m] shifts [n] to the left by [m] bits.
+   The result is unspecified if [m < 0] or [m >= bitsize],
+   where [bitsize] is [32] on a 32-bit platform and
+   [64] on a 64-bit platform. *)
+
+external ( lsr ) : int -> int -> int = "%lsrint"
+(** [n lsr m] shifts [n] to the right by [m] bits.
+   This is a logical shift: zeroes are inserted regardless of
+   the sign of [n].
+   The result is unspecified if [m < 0] or [m >= bitsize]. *)
+
+external ( asr ) : int -> int -> int = "%asrint"
+(** [n asr m] shifts [n] to the right by [m] bits.
+   This is an arithmetic shift: the sign bit of [n] is replicated.
+   The result is unspecified if [m < 0] or [m >= bitsize]. *)
+
+
+(** {6 Floating-point arithmetic}
+
+   OCaml's floating-point numbers follow the
+   IEEE 754 standard, using double precision (64 bits) numbers.
+   Floating-point operations never raise an exception on overflow,
+   underflow, division by zero, etc.  Instead, special IEEE numbers
+   are returned as appropriate, such as [infinity] for [1.0 /. 0.0],
+   [neg_infinity] for [-1.0 /. 0.0], and [nan] (``not a number'')
+   for [0.0 /. 0.0].  These special numbers then propagate through
+   floating-point computations as expected: for instance,
+   [1.0 /. infinity] is [0.0], and any arithmetic operation with [nan]
+   as argument returns [nan] as result.
+*)
+
+external ( ~-. ) : float -> float = "%negfloat"
+(** Unary negation. You can also write [-. e] instead of [~-. e]. *)
+
+external ( ~+. ) : float -> float = "%identity"
+(** Unary addition. You can also write [+. e] instead of [~+. e].
+    @since 3.12.0
+*)
+
+external ( +. ) : float -> float -> float = "%addfloat"
+(** Floating-point addition *)
+
+external ( -. ) : float -> float -> float = "%subfloat"
+(** Floating-point subtraction *)
+
+external ( *. ) : float -> float -> float = "%mulfloat"
+(** Floating-point multiplication *)
+
+external ( /. ) : float -> float -> float = "%divfloat"
+(** Floating-point division. *)
+
+external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
+(** Exponentiation. *)
+
+external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
+(** Square root. *)
+
+external exp : float -> float = "caml_exp_float" "exp" "float"
+(** Exponential. *)
+
+external log : float -> float = "caml_log_float" "log" "float"
+(** Natural logarithm. *)
+
+external log10 : float -> float = "caml_log10_float" "log10" "float"
+(** Base 10 logarithm. *)
+
+external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
+(** [expm1 x] computes [exp x -. 1.0], giving numerically-accurate results
+    even if [x] is close to [0.0].
+    @since 3.12.0
+*)
+
+external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
+(** [log1p x] computes [log(1.0 +. x)] (natural logarithm),
+    giving numerically-accurate results even if [x] is close to [0.0].
+    @since 3.12.0
+*)
+
+external cos : float -> float = "caml_cos_float" "cos" "float"
+(** Cosine.  Argument is in radians. *)
+
+external sin : float -> float = "caml_sin_float" "sin" "float"
+(** Sine.  Argument is in radians. *)
+
+external tan : float -> float = "caml_tan_float" "tan" "float"
+(** Tangent.  Argument is in radians. *)
+
+external acos : float -> float = "caml_acos_float" "acos" "float"
+(** Arc cosine.  The argument must fall within the range [[-1.0, 1.0]].
+    Result is in radians and is between [0.0] and [pi]. *)
+
+external asin : float -> float = "caml_asin_float" "asin" "float"
+(** Arc sine.  The argument must fall within the range [[-1.0, 1.0]].
+    Result is in radians and is between [-pi/2] and [pi/2]. *)
+
+external atan : float -> float = "caml_atan_float" "atan" "float"
+(** Arc tangent.
+    Result is in radians and is between [-pi/2] and [pi/2]. *)
+
+external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
+(** [atan2 y x] returns the arc tangent of [y /. x].  The signs of [x]
+    and [y] are used to determine the quadrant of the result.
+    Result is in radians and is between [-pi] and [pi]. *)
+
+external hypot : float -> float -> float
+               = "caml_hypot_float" "caml_hypot" "float"
+(** [hypot x y] returns [sqrt(x *. x + y *. y)], that is, the length
+  of the hypotenuse of a right-angled triangle with sides of length
+  [x] and [y], or, equivalently, the distance of the point [(x,y)]
+  to origin.
+  @since 4.00.0  *)
+
+external cosh : float -> float = "caml_cosh_float" "cosh" "float"
+(** Hyperbolic cosine.  Argument is in radians. *)
+
+external sinh : float -> float = "caml_sinh_float" "sinh" "float"
+(** Hyperbolic sine.  Argument is in radians. *)
+
+external tanh : float -> float = "caml_tanh_float" "tanh" "float"
+(** Hyperbolic tangent.  Argument is in radians. *)
+
+external ceil : float -> float = "caml_ceil_float" "ceil" "float"
+(** Round above to an integer value.
+    [ceil f] returns the least integer value greater than or equal to [f].
+    The result is returned as a float. *)
+
+external floor : float -> float = "caml_floor_float" "floor" "float"
+(** Round below to an integer value.
+    [floor f] returns the greatest integer value less than or
+    equal to [f].
+    The result is returned as a float. *)
+
+external abs_float : float -> float = "%absfloat"
+(** [abs_float f] returns the absolute value of [f]. *)
+
+external copysign : float -> float -> float
+                  = "caml_copysign_float" "caml_copysign" "float"
+(** [copysign x y] returns a float whose absolute value is that of [x]
+  and whose sign is that of [y].  If [x] is [nan], returns [nan].
+  If [y] is [nan], returns either [x] or [-. x], but it is not
+  specified which.
+  @since 4.00.0  *)
+
+external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
+(** [mod_float a b] returns the remainder of [a] with respect to
+   [b].  The returned value is [a -. n *. b], where [n]
+   is the quotient [a /. b] rounded towards zero to an integer. *)
+
+external frexp : float -> float * int = "caml_frexp_float"
+(** [frexp f] returns the pair of the significant
+   and the exponent of [f].  When [f] is zero, the
+   significant [x] and the exponent [n] of [f] are equal to
+   zero.  When [f] is non-zero, they are defined by
+   [f = x *. 2 ** n] and [0.5 <= x < 1.0]. *)
+
+external ldexp : float -> int -> float = "caml_ldexp_float"
+(** [ldexp x n] returns [x *. 2 ** n]. *)
+
+external modf : float -> float * float = "caml_modf_float"
+(** [modf f] returns the pair of the fractional and integral
+   part of [f]. *)
+
+external float : int -> float = "%floatofint"
+(** Same as {!Pervasives.float_of_int}. *)
+
+external float_of_int : int -> float = "%floatofint"
+(** Convert an integer to floating-point. *)
+
+external truncate : float -> int = "%intoffloat"
+(** Same as {!Pervasives.int_of_float}. *)
+
+external int_of_float : float -> int = "%intoffloat"
+(** Truncate the given floating-point number to an integer.
+   The result is unspecified if the argument is [nan] or falls outside the
+   range of representable integers. *)
+
+val infinity : float
+(** Positive infinity. *)
+
+val neg_infinity : float
+(** Negative infinity. *)
+
+val nan : float
+(** A special floating-point value denoting the result of an
+   undefined operation such as [0.0 /. 0.0].  Stands for
+   ``not a number''.  Any floating-point operation with [nan] as
+   argument returns [nan] as result.  As for floating-point comparisons,
+   [=], [<], [<=], [>] and [>=] return [false] and [<>] returns [true]
+   if one or both of their arguments is [nan]. *)
+
+val max_float : float
+(** The largest positive finite value of type [float]. *)
+
+val min_float : float
+(** The smallest positive, non-zero, non-denormalized value of type [float]. *)
+
+val epsilon_float : float
+(** The difference between [1.0] and the smallest exactly representable
+    floating-point number greater than [1.0]. *)
+
+type fpclass =
+    FP_normal           (** Normal number, none of the below *)
+  | FP_subnormal        (** Number very close to 0.0, has reduced precision *)
+  | FP_zero             (** Number is 0.0 or -0.0 *)
+  | FP_infinite         (** Number is positive or negative infinity *)
+  | FP_nan              (** Not a number: result of an undefined operation *)
+(** The five classes of floating-point numbers, as determined by
+   the {!Pervasives.classify_float} function. *)
+
+external classify_float : float -> fpclass = "caml_classify_float"
+(** Return the class of the given floating-point number:
+   normal, subnormal, zero, infinite, or not a number. *)
+
+
+(** {6 String operations}
+
+   More string operations are provided in module {!String}.
+*)
+
+val ( ^ ) : string -> string -> string
+(** String concatenation. *)
+
+
+(** {6 Character operations}
+
+   More character operations are provided in module {!Char}.
+*)
+
+external int_of_char : char -> int = "%identity"
+(** Return the ASCII code of the argument. *)
+
+val char_of_int : int -> char
+(** Return the character with the given ASCII code.
+   Raise [Invalid_argument "char_of_int"] if the argument is
+   outside the range 0--255. *)
+
+
+(** {6 Unit operations} *)
+
+external ignore : 'a -> unit = "%ignore"
+(** Discard the value of its argument and return [()].
+   For instance, [ignore(f x)] discards the result of
+   the side-effecting function [f].  It is equivalent to
+   [f x; ()], except that the latter may generate a
+   compiler warning; writing [ignore(f x)] instead
+   avoids the warning. *)
+
+
+(** {6 String conversion functions} *)
+
+val string_of_bool : bool -> string
+(** Return the string representation of a boolean. As the returned values
+   may be shared, the user should not modify them directly.
+*)
+
+val bool_of_string : string -> bool
+(** Convert the given string to a boolean.
+   Raise [Invalid_argument "bool_of_string"] if the string is not
+   ["true"] or ["false"]. *)
+
+val string_of_int : int -> string
+(** Return the string representation of an integer, in decimal. *)
+
+external int_of_string : string -> int = "caml_int_of_string"
+(** Convert the given string to an integer.
+   The string is read in decimal (by default) or in hexadecimal (if it
+   begins with [0x] or [0X]), octal (if it begins with [0o] or [0O]),
+   or binary (if it begins with [0b] or [0B]).
+   Raise [Failure "int_of_string"] if the given string is not
+   a valid representation of an integer, or if the integer represented
+   exceeds the range of integers representable in type [int]. *)
+
+val string_of_float : float -> string
+(** Return the string representation of a floating-point number. *)
+
+external float_of_string : string -> float = "caml_float_of_string"
+(** Convert the given string to a float.  Raise [Failure "float_of_string"]
+   if the given string is not a valid representation of a float. *)
+
+
+(** {6 Pair operations} *)
+
+external fst : 'a * 'b -> 'a = "%field0"
+(** Return the first component of a pair. *)
+
+external snd : 'a * 'b -> 'b = "%field1"
+(** Return the second component of a pair. *)
+
+
+(** {6 List operations}
+
+   More list operations are provided in module {!List}.
+*)
+
+val ( @ ) : 'a list -> 'a list -> 'a list
+(** List concatenation. *)
+
+
+(** {6 Input/output}
+    Note: all input/output functions can raise [Sys_error] when the system
+    calls they invoke fail. *)
+
+type in_channel
+(** The type of input channel. *)
+
+type out_channel
+(** The type of output channel. *)
+
+val stdin : in_channel
+(** The standard input for the process. *)
+
+val stdout : out_channel
+(** The standard output for the process. *)
+
+val stderr : out_channel
+(** The standard error output for the process. *)
+
+
+(** {7 Output functions on standard output} *)
+
+val print_char : char -> unit
+(** Print a character on standard output. *)
+
+val print_string : string -> unit
+(** Print a string on standard output. *)
+
+val print_int : int -> unit
+(** Print an integer, in decimal, on standard output. *)
+
+val print_float : float -> unit
+(** Print a floating-point number, in decimal, on standard output. *)
+
+val print_endline : string -> unit
+(** Print a string, followed by a newline character, on
+   standard output and flush standard output. *)
+
+val print_newline : unit -> unit
+(** Print a newline character on standard output, and flush
+   standard output. This can be used to simulate line
+   buffering of standard output. *)
+
+
+(** {7 Output functions on standard error} *)
+
+val prerr_char : char -> unit
+(** Print a character on standard error. *)
+
+val prerr_string : string -> unit
+(** Print a string on standard error. *)
+
+val prerr_int : int -> unit
+(** Print an integer, in decimal, on standard error. *)
+
+val prerr_float : float -> unit
+(** Print a floating-point number, in decimal, on standard error. *)
+
+val prerr_endline : string -> unit
+(** Print a string, followed by a newline character on standard error
+   and flush standard error. *)
+
+val prerr_newline : unit -> unit
+(** Print a newline character on standard error, and flush
+   standard error. *)
+
+
+(** {7 Input functions on standard input} *)
+
+val read_line : unit -> string
+(** Flush standard output, then read characters from standard input
+   until a newline character is encountered. Return the string of
+   all characters read, without the newline character at the end. *)
+
+val read_int : unit -> int
+(** Flush standard output, then read one line from standard input
+   and convert it to an integer. Raise [Failure "int_of_string"]
+   if the line read is not a valid representation of an integer. *)
+
+val read_float : unit -> float
+(** Flush standard output, then read one line from standard input
+   and convert it to a floating-point number.
+   The result is unspecified if the line read is not a valid
+   representation of a floating-point number. *)
+
+
+(** {7 General output functions} *)
+
+type open_flag =
+    Open_rdonly      (** open for reading. *)
+  | Open_wronly      (** open for writing. *)
+  | Open_append      (** open for appending: always write at end of file. *)
+  | Open_creat       (** create the file if it does not exist. *)
+  | Open_trunc       (** empty the file if it already exists. *)
+  | Open_excl        (** fail if Open_creat and the file already exists. *)
+  | Open_binary      (** open in binary mode (no conversion). *)
+  | Open_text        (** open in text mode (may perform conversions). *)
+  | Open_nonblock    (** open in non-blocking mode. *)
+(** Opening modes for {!Pervasives.open_out_gen} and
+  {!Pervasives.open_in_gen}. *)
+
+val open_out : string -> out_channel
+(** Open the named file for writing, and return a new output channel
+   on that file, positionned at the beginning of the file. The
+   file is truncated to zero length if it already exists. It
+   is created if it does not already exists.
+   Raise [Sys_error] if the file could not be opened. *)
+
+val open_out_bin : string -> out_channel
+(** Same as {!Pervasives.open_out}, but the file is opened in binary mode,
+   so that no translation takes place during writes. On operating
+   systems that do not distinguish between text mode and binary
+   mode, this function behaves like {!Pervasives.open_out}. *)
+
+val open_out_gen : open_flag list -> int -> string -> out_channel
+(** [open_out_gen mode perm filename] opens the named file for writing,
+   as described above. The extra argument [mode]
+   specify the opening mode. The extra argument [perm] specifies
+   the file permissions, in case the file must be created.
+   {!Pervasives.open_out} and {!Pervasives.open_out_bin} are special
+   cases of this function. *)
+
+val flush : out_channel -> unit
+(** Flush the buffer associated with the given output channel,
+   performing all pending writes on that channel.
+   Interactive programs must be careful about flushing standard
+   output and standard error at the right time. *)
+
+val flush_all : unit -> unit
+(** Flush all open output channels; ignore errors. *)
+
+val output_char : out_channel -> char -> unit
+(** Write the character on the given output channel. *)
+
+val output_string : out_channel -> string -> unit
+(** Write the string on the given output channel. *)
+
+val output : out_channel -> string -> int -> int -> unit
+(** [output oc buf pos len] writes [len] characters from string [buf],
+   starting at offset [pos], to the given output channel [oc].
+   Raise [Invalid_argument "output"] if [pos] and [len] do not
+   designate a valid substring of [buf]. *)
+
+val output_byte : out_channel -> int -> unit
+(** Write one 8-bit integer (as the single character with that code)
+   on the given output channel. The given integer is taken modulo
+   256. *)
+
+val output_binary_int : out_channel -> int -> unit
+(** Write one integer in binary format (4 bytes, big-endian)
+   on the given output channel.
+   The given integer is taken modulo 2{^32}.
+   The only reliable way to read it back is through the
+   {!Pervasives.input_binary_int} function. The format is compatible across
+   all machines for a given version of OCaml. *)
+
+val output_value : out_channel -> 'a -> unit
+(** Write the representation of a structured value of any type
+   to a channel. Circularities and sharing inside the value
+   are detected and preserved. The object can be read back,
+   by the function {!Pervasives.input_value}. See the description of module
+   {!Marshal} for more information. {!Pervasives.output_value} is equivalent
+   to {!Marshal.to_channel} with an empty list of flags. *)
+
+val seek_out : out_channel -> int -> unit
+(** [seek_out chan pos] sets the current writing position to [pos]
+   for channel [chan]. This works only for regular files. On
+   files of other kinds (such as terminals, pipes and sockets),
+   the behavior is unspecified. *)
+
+val pos_out : out_channel -> int
+(** Return the current writing position for the given channel.  Does
+    not work on channels opened with the [Open_append] flag (returns
+    unspecified results). *)
+
+val out_channel_length : out_channel -> int
+(** Return the size (number of characters) of the regular file
+   on which the given channel is opened.  If the channel is opened
+    on a file that is not a regular file, the result is meaningless. *)
+
+val close_out : out_channel -> unit
+(** Close the given channel, flushing all buffered write operations.
+   Output functions raise a [Sys_error] exception when they are
+   applied to a closed output channel, except [close_out] and [flush],
+   which do nothing when applied to an already closed channel.
+   Note that [close_out] may raise [Sys_error] if the operating
+   system signals an error when flushing or closing. *)
+
+val close_out_noerr : out_channel -> unit
+(** Same as [close_out], but ignore all errors. *)
+
+val set_binary_mode_out : out_channel -> bool -> unit
+(** [set_binary_mode_out oc true] sets the channel [oc] to binary
+   mode: no translations take place during output.
+   [set_binary_mode_out oc false] sets the channel [oc] to text
+   mode: depending on the operating system, some translations
+   may take place during output.  For instance, under Windows,
+   end-of-lines will be translated from [\n] to [\r\n].
+   This function has no effect under operating systems that
+   do not distinguish between text mode and binary mode. *)
+
+
+(** {7 General input functions} *)
+
+val open_in : string -> in_channel
+(** Open the named file for reading, and return a new input channel
+   on that file, positionned at the beginning of the file.
+   Raise [Sys_error] if the file could not be opened. *)
+
+val open_in_bin : string -> in_channel
+(** Same as {!Pervasives.open_in}, but the file is opened in binary mode,
+   so that no translation takes place during reads. On operating
+   systems that do not distinguish between text mode and binary
+   mode, this function behaves like {!Pervasives.open_in}. *)
+
+val open_in_gen : open_flag list -> int -> string -> in_channel
+(** [open_in_gen mode perm filename] opens the named file for reading,
+   as described above. The extra arguments
+   [mode] and [perm] specify the opening mode and file permissions.
+   {!Pervasives.open_in} and {!Pervasives.open_in_bin} are special
+   cases of this function. *)
+
+val input_char : in_channel -> char
+(** Read one character from the given input channel.
+   Raise [End_of_file] if there are no more characters to read. *)
+
+val input_line : in_channel -> string
+(** Read characters from the given input channel, until a
+   newline character is encountered. Return the string of
+   all characters read, without the newline character at the end.
+   Raise [End_of_file] if the end of the file is reached
+   at the beginning of line. *)
+
+val input : in_channel -> string -> int -> int -> int
+(** [input ic buf pos len] reads up to [len] characters from
+   the given channel [ic], storing them in string [buf], starting at
+   character number [pos].
+   It returns the actual number of characters read, between 0 and
+   [len] (inclusive).
+   A return value of 0 means that the end of file was reached.
+   A return value between 0 and [len] exclusive means that
+   not all requested [len] characters were read, either because
+   no more characters were available at that time, or because
+   the implementation found it convenient to do a partial read;
+   [input] must be called again to read the remaining characters,
+   if desired.  (See also {!Pervasives.really_input} for reading
+   exactly [len] characters.)
+   Exception [Invalid_argument "input"] is raised if [pos] and [len]
+   do not designate a valid substring of [buf]. *)
+
+val really_input : in_channel -> string -> int -> int -> unit
+(** [really_input ic buf pos len] reads [len] characters from channel [ic],
+   storing them in string [buf], starting at character number [pos].
+   Raise [End_of_file] if the end of file is reached before [len]
+   characters have been read.
+   Raise [Invalid_argument "really_input"] if
+   [pos] and [len] do not designate a valid substring of [buf]. *)
+
+val input_byte : in_channel -> int
+(** Same as {!Pervasives.input_char}, but return the 8-bit integer representing
+   the character.
+   Raise [End_of_file] if an end of file was reached. *)
+
+val input_binary_int : in_channel -> int
+(** Read an integer encoded in binary format (4 bytes, big-endian)
+   from the given input channel. See {!Pervasives.output_binary_int}.
+   Raise [End_of_file] if an end of file was reached while reading the
+   integer. *)
+
+val input_value : in_channel -> 'a
+(** Read the representation of a structured value, as produced
+   by {!Pervasives.output_value}, and return the corresponding value.
+   This function is identical to {!Marshal.from_channel};
+   see the description of module {!Marshal} for more information,
+   in particular concerning the lack of type safety. *)
+
+val seek_in : in_channel -> int -> unit
+(** [seek_in chan pos] sets the current reading position to [pos]
+   for channel [chan]. This works only for regular files. On
+   files of other kinds, the behavior is unspecified. *)
+
+val pos_in : in_channel -> int
+(** Return the current reading position for the given channel. *)
+
+val in_channel_length : in_channel -> int
+(** Return the size (number of characters) of the regular file
+    on which the given channel is opened.  If the channel is opened
+    on a file that is not a regular file, the result is meaningless.
+    The returned size does not take into account the end-of-line
+    translations that can be performed when reading from a channel
+    opened in text mode. *)
+
+val close_in : in_channel -> unit
+(** Close the given channel.  Input functions raise a [Sys_error]
+  exception when they are applied to a closed input channel,
+  except [close_in], which does nothing when applied to an already
+  closed channel.  Note that [close_in] may raise [Sys_error] if
+  the operating system signals an error. *)
+
+val close_in_noerr : in_channel -> unit
+(** Same as [close_in], but ignore all errors. *)
+
+val set_binary_mode_in : in_channel -> bool -> unit
+(** [set_binary_mode_in ic true] sets the channel [ic] to binary
+   mode: no translations take place during input.
+   [set_binary_mode_out ic false] sets the channel [ic] to text
+   mode: depending on the operating system, some translations
+   may take place during input.  For instance, under Windows,
+   end-of-lines will be translated from [\r\n] to [\n].
+   This function has no effect under operating systems that
+   do not distinguish between text mode and binary mode. *)
+
+
+(** {7 Operations on large files} *)
+
+module LargeFile :
+  sig
+    val seek_out : out_channel -> int64 -> unit
+    val pos_out : out_channel -> int64
+    val out_channel_length : out_channel -> int64
+    val seek_in : in_channel -> int64 -> unit
+    val pos_in : in_channel -> int64
+    val in_channel_length : in_channel -> int64
+  end
+(** Operations on large files.
+  This sub-module provides 64-bit variants of the channel functions
+  that manipulate file positions and file sizes.  By representing
+  positions and sizes by 64-bit integers (type [int64]) instead of
+  regular integers (type [int]), these alternate functions allow
+  operating on files whose sizes are greater than [max_int]. *)
+
+
+(** {6 References} *)
+
+type 'a ref = { mutable contents : 'a }
+(** The type of references (mutable indirection cells) containing
+   a value of type ['a]. *)
+
+external ref : 'a -> 'a ref = "%makemutable"
+(** Return a fresh reference containing the given value. *)
+
+external ( ! ) : 'a ref -> 'a = "%field0"
+(** [!r] returns the current contents of reference [r].
+   Equivalent to [fun r -> r.contents]. *)
+
+external ( := ) : 'a ref -> 'a -> unit = "%setfield0"
+(** [r := a] stores the value of [a] in reference [r].
+   Equivalent to [fun r v -> r.contents <- v]. *)
+
+external incr : int ref -> unit = "%incr"
+(** Increment the integer contained in the given reference.
+   Equivalent to [fun r -> r := succ !r]. *)
+
+external decr : int ref -> unit = "%decr"
+(** Decrement the integer contained in the given reference.
+   Equivalent to [fun r -> r := pred !r]. *)
+
+
+(** {6 Operations on format strings} *)
+
+(** Format strings are used to read and print data using formatted input
+    functions in module {!Scanf} and formatted output in modules {!Printf} and
+    {!Format}. *)
+
+(** Format strings have a general and highly polymorphic type
+    [('a, 'b, 'c, 'd, 'e, 'f) format6]. Type [format6] is built in.
+    The two simplified types, [format] and [format4] below are
+    included for backward compatibility with earlier releases of OCaml.
+    ['a] is the type of the parameters of the format,
+    ['b] is the type of the first argument given to
+         [%a] and [%t] printing functions,
+    ['c] is the type of the result of the [%a] and [%t] functions, and
+         also the type of the argument transmitted to the first argument
+         of [kprintf]-style functions,
+    ['d] is the result type for the [scanf]-style functions,
+    ['e] is the type of the receiver function for the [scanf]-style functions,
+    ['f] is the result type for the [printf]-style function.
+ *)
+type ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6
+
+type ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4
+
+val string_of_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
+(** Converts a format string into a string. *)
+
+external format_of_string :
+  ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+  ('a, 'b, 'c, 'd, 'e, 'f) format6 = "%identity"
+(** [format_of_string s] returns a format string read from the string
+    literal [s]. *)
+
+val ( ^^ ) :
+      ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
+      ('f, 'b, 'c, 'e, 'g, 'h) format6 ->
+      ('a, 'b, 'c, 'd, 'g, 'h) format6
+(** [f1 ^^ f2] catenates formats [f1] and [f2].  The result is a format
+  that accepts arguments from [f1], then arguments from [f2]. *)
+
+
+(** {6 Program termination} *)
+
+val exit : int -> 'a
+(** Terminate the process, returning the given status code
+   to the operating system: usually 0 to indicate no errors,
+   and a small positive integer to indicate failure.
+   All open output channels are flushed with [flush_all].
+   An implicit [exit 0] is performed each time a program
+   terminates normally.  An implicit [exit 2] is performed if the program
+   terminates early because of an uncaught exception. *)
+
+val at_exit : (unit -> unit) -> unit
+(** Register the given function to be called at program
+   termination time. The functions registered with [at_exit]
+   will be called when the program executes {!Pervasives.exit},
+   or terminates, either normally or because of an uncaught exception.
+   The functions are called in ``last in, first out'' order:
+   the function most recently added with [at_exit] is called first. *)
+
+(**/**)
+
+(* The following is for system use only. Do not call directly. *)
+
+val valid_float_lexem : string -> string
+
+val unsafe_really_input : in_channel -> string -> int -> int -> unit
+
+val do_at_exit : unit -> unit
diff -urN ocaml-4.00/tools/Makefile.shared ocaml-4.00-android/tools/Makefile.shared
--- ocaml-4.00/tools/Makefile.shared	2012-04-26 23:17:53.000000000 +0400
+++ ocaml-4.00-android/tools/Makefile.shared	2012-05-11 16:15:48.000000000 +0400
@@ -14,10 +14,12 @@
 
 include ../config/Makefile
 
-CAMLRUN=../boot/ocamlrun
-CAMLC=$(CAMLRUN) ../boot/ocamlc -strict-sequence -nostdlib -I ../boot
-CAMLOPT=$(CAMLRUN) ../ocamlopt -nostdlib -I ../stdlib
-CAMLLEX=$(CAMLRUN) ../boot/ocamllex
+CAMLRUN=ocamlrun
+CAMLC=ocamlc.opt -strict-sequence 
+#-nostdlib -I ../boot
+CAMLOPT=ocamlopt.opt
+#-nostdlib -I ../stdlib
+CAMLLEX=ocamllex
 INCLUDES=-I ../utils -I ../parsing -I ../typing -I ../bytecomp -I ../asmcomp \
 	 -I ../driver
 COMPFLAGS= -warn-error A $(INCLUDES)
